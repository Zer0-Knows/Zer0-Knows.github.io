
<!DOCTYPE html>
<html lang="ch" class="loading">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>linux系统管理 - Zer0 Blog</title>
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate" />
    <meta name="keywords" content="Zer0,"> 
    <meta name="description" content="一、进程管理1、进程简介1）、什么是进程管理？
那么到底什么是进程呢？进程是正在执行的一个程序或命令，每一个进程都是一个运行的实体，都有自己的地址空间，并占用一定的系统资源。那么什么是程序呢？程序是,"> 
    <meta name="author" content="Zer0_Nos"> 
    <link rel="alternative" href="atom.xml" title="Zer0 Blog" type="application/atom+xml"> 
    <link rel="icon" href="/img/favicon.png"> 
    
    
<link rel="stylesheet" href="/css/diaspora.css">

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
         (adsbygoogle = window.adsbygoogle || []).push({
              google_ad_client: "ca-pub-8691406134231910",
              enable_page_level_ads: true
         });
    </script>
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
<meta name="generator" content="Hexo 4.2.0"></head>

<body class="loading">
    <span id="config-title" style="display:none">Zer0 Blog</span>
    <div id="loader"></div>
    <div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="iconfont icon-home image-icon" href="javascript:;" data-url="http://yoursite.com"></a>
    <div title="播放/暂停" class="iconfont icon-play"></div>
    <h3 class="subtitle">linux系统管理</h3>
    <div class="social">
        <div>
            <div class="share">
                <a title="获取二维码" class="iconfont icon-scan" href="javascript:;"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>

    <div class="section">
        <div class="article">
    <div class='main'>
        <h1 class="title">linux系统管理</h1>
        <div class="stuff">
            <span>十一月 03, 2020</span>
            
  <ul class="post-tags-list" itemprop="keywords"><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/linux%E8%BF%90%E7%BB%B4%E5%9F%BA%E7%A1%80/" rel="tag">linux运维基础</a></li></ul>


        </div>
        <div class="content markdown">
            <h2 id="一、进程管理"><a href="#一、进程管理" class="headerlink" title="一、进程管理"></a>一、进程管理</h2><h3 id="1、进程简介"><a href="#1、进程简介" class="headerlink" title="1、进程简介"></a>1、进程简介</h3><p>1）、什么是进程管理？</p>
<p>那么到底什么是进程呢？进程是正在执行的一个程序或命令，每一个进程都是一个运行的实体，都有自己的地址空间，并占用一定的系统资源。那么什么是程序呢？程序是人使用计算机语言编写的可以实现特定目标或解决特定问题的代码集合。这么讲很难理解，那我们换一种说法：</p>
<ul>
<li>程序是人使用计算机语言编写的，可以实现一定功能，并且可以执行的代码集合。</li>
<li>进程是正在执行当中的程序。程序被执行时，执行人的权限和属性、以及程序的代码都会被加载如内存，操作系统给这个进程分配一个ID号，我们成为PID（进程ID）。    </li>
</ul>
<p>2）、进程管理的作用</p>
<ul>
<li>判断服务器健康状态：运维工程师最主要的工作就是保证服务器安全稳定的运行。理想的状态是，在服务器出现问题，但是还没有造成服务器宕机或停止服务时，就人为干预解决了问题。进程管理最主要的工作就是判断服务器当前运行是否健康，是否需要人为干预。如果服务器的CPU占用率、内存占用率过高，就需要人为介入解决问题了。</li>
<li>查看系统中所有的进程：我们需要查看系统中所有正在运行的进程，通过这些进程可以判断系统中运行了哪些服务，是否有非法服务运行。</li>
<li>杀死进程：这是进程管理中最不常用的手段，当我需要停止服务时，会通过正确关闭命令来停止服务（如apache服务可以通过service httpd stop来关闭）。只有当正确终止进程的手段失效的情况下，才会考虑使用kill命令杀死进程（你不是杀手，不要什么进程都用kill来终止，否则非常容易导致服务器崩溃）。</li>
</ul>
<h3 id="2、进程的查看"><a href="#2、进程的查看" class="headerlink" title="2、进程的查看"></a>2、进程的查看</h3><p>1）、   ps命令    </p>
<p>ps命令是用来静态显示系统中进程的命令。不过这个命令有些特殊，它的部分命令的选项不能加入“-”，比如命令“ps  aux”，其中“aux”是选项，但是这个选项不能加入“-”。这是因为ps命令的部分选项需要遵守BSD操作系统的格式。所以ps命令的常用选项的组合是固定的。命令如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ps aux</span><br><span class="line">#查看系统中所有进程，使用BSD操作系统格式</span><br><span class="line">[root@localhost ~]# ps -le  </span><br><span class="line">#查看系统中所有进程，使用Linux标准命令格式。</span><br><span class="line">选项：    </span><br><span class="line">a：显示一个终端的所有进程，除了会话引线    </span><br><span class="line">u：显示进程的归属用户及内存的使用情况    </span><br><span class="line">x：显示没有控制终端的进程</span><br><span class="line">-l：长格式显示。显示更加详细的信息    </span><br><span class="line">-e：显示所有进程，和-A作用一致</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ps aux</span><br><span class="line">#查看系统中所有的进程</span><br><span class="line">USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span><br><span class="line">root         1  0.0  0.2   2872  1416 ?        Ss   Jun04   0:02 &#x2F;sbin&#x2F;init</span><br><span class="line">root         2  0.0  0.0      0     0 ?        S    Jun04   0:00 [kthreadd]</span><br></pre></td></tr></table></figure>

<p>解释下这个命令的输出：</p>
<ul>
<li><p>USER：该进程是由哪个用户产生的；</p>
</li>
<li><p>PID：进程的ID号；</p>
</li>
<li><p>%CPU：该进程占用CPU资源的百分比，占用越高，进程越耗费资源；</p>
</li>
<li><p>%MEM：该进程占用物理内存的百分比，占用越高，进程越耗费资源；</p>
</li>
<li><p>VSZ：该进程占用虚拟内存的大小，单位KB；</p>
</li>
<li><p>RSS：该进程占用实际物理内存的大小，单位KB；</p>
</li>
<li><p>TTY：该进程是在哪个终端中运行的。其中tty1-tty7代表本地控制台终端（可以通过alt+F1-F7键切换不同的终端），tty1-tty6是本地的字符界面终端，tty7是图形终端。pts/0-255代表虚拟终端，一般是远程连接的终端，第一个远程连接占用的是pts/0终端，第二个远程连接占用pts/1，依次增长。</p>
</li>
<li><p>STAT：进程状态。常见的状态有：</p>
<ul>
<li><p>D：不可被唤醒的睡眠状态，通常用于I/O情况</p>
</li>
<li><p>R：该进程正在运行</p>
</li>
<li><p>S：该进程在睡眠状态，可被唤醒</p>
</li>
<li><p>T：停止状态，可能是在后台暂停或进程在除错状态</p>
</li>
<li><p>W：内存交互状态（从2.6内核开始无效）</p>
</li>
<li><p>X：死掉的进程（应该不会出现）</p>
</li>
<li><p>Z：僵尸进程。进程已经终止，但是部分程序还在内存当中。</p>
<p>&lt;：高优先级（以下状态在BSD格式当中出现）</p>
<p>N：低优先级</p>
<p>L：被锁入内存</p>
<p>s：包含子进程</p>
<p>l：多线程（小写L）</p>
<p>+：位于后台</p>
</li>
</ul>
</li>
<li><p>START：该进程的启动时间</p>
</li>
<li><p>TIME：该进程占用CPU的运算时间，注意不是系统时间</p>
</li>
<li><p>COMMAND：产生此进程的命令名</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ps -le  </span><br><span class="line">F S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD</span><br><span class="line">4 S     0     1     0  0  80   0 -    718 -      ?        00:00:02 init </span><br><span class="line">1 S     0     2     0  0  80   0 -     0 -       ?        00:00:00 kthreadd</span><br></pre></td></tr></table></figure>

<p>也来解释下这个命令的输出：</p>
<ul>
<li><p>F：进程标志，说明进程的权限，常见的标志有：</p>
<ul>
<li>1：进程可以复制，但是不能执行</li>
<li>4：进程使用超级用户权限</li>
</ul>
</li>
<li><p>S：进程状态。具体的状态和“ps aux”命令中STAT状态一致</p>
</li>
<li><p>UID：进程是哪个UID用户调用运行的</p>
</li>
<li><p>PID：进程的ID号</p>
</li>
<li><p>PPID：父进程的ID号</p>
</li>
<li><p>C：该进程的CPU使用率，单位是百分比PRI：进程的优先级，数值越小该进程优先级越高，越快被CPU执行NI：进程的优先级，也是数值越小越早被执行</p>
</li>
<li><p>ADDR：该进程在内存的哪个位置</p>
</li>
<li><p>SZ：该进程占用多大内存</p>
</li>
<li><p>WCHAN：该进程是否运行。“-”代表正在运行</p>
</li>
<li><p>TTY：该进程由哪个终端产生</p>
</li>
<li><p>TIME：该进程占用CPU的运算时间，注意不是系统时间</p>
</li>
<li><p>CMD：产生此进程的命令名    </p>
</li>
</ul>
<p>2)、    top命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# top [选项] </span><br><span class="line">选项：    </span><br><span class="line">-d 秒数：指定top命令每隔几秒更新。默认是3秒    </span><br><span class="line">-b：使用批处理模式输出。一般和“-n”选项合用，用于把top命令重定向到文件中    </span><br><span class="line">-n 次数：指定top命令执行的次数。一般和“-b”选项合用    </span><br><span class="line">-p：指定PID。只查看某个PID的进程    </span><br><span class="line">-s：使top在安全模式运行，避免在交互模式中出现错误    </span><br><span class="line">-u 用户名：只监听某个用户的进程在top命令的交互模式当中可以执行的命令：？或h：显示交互模式的帮助    </span><br><span class="line">P：以CPU使用率排序，默认就是此项    </span><br><span class="line">M：以内存的使用率排序    </span><br><span class="line">N：以PID排序    </span><br><span class="line">T：按照CPU的累积运算时间排序，也就是用TIME+项排序    </span><br><span class="line">k：按照PID号，给予某个进程一个信号。一般用于终止某个进程，信号9 是强制终止的信号    </span><br><span class="line">r：按照PID号，给某个进程重设优先级（Nice）值    </span><br><span class="line">q：退出top</span><br></pre></td></tr></table></figure>

<p>我们看看top命令的执行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# top</span><br><span class="line">top - 12:26:46 up 1 day, 13:32,  2 users,  load average: 0.00, 0.00, 0.00</span><br><span class="line">Tasks:  95 total,   1 running,  94 sleeping,   0 stopped,   0 zombie</span><br><span class="line">Cpu(s):  0.1%us,  0.1%sy,  0.0%ni, 99.7%id,  0.1%wa,  0.0%hi,  0.1%si,  0.0%st</span><br><span class="line">Mem:    625344k total,   571504k used,    53840k free,    65800k buffers</span><br><span class="line">Swap:   524280k total,        0k used,   524280k free,   409280k cached</span><br><span class="line"></span><br><span class="line">PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND          </span><br><span class="line">19002 root      20   0  2656 1068  856 R  0.3  0.2   0:01.87 top                </span><br><span class="line">1 root      20   0  2872 1416 1200 S  0.0  0.2   0:02.55 init                  </span><br><span class="line">2 root      20   0     0    0    0 S  0.0  0.0   0:00.03 kthreadd</span><br></pre></td></tr></table></figure>

<p>我们解释下命令的输出，top命令的输出内容是动态的，默认每3秒刷新一次。命令的输出主要分为两大部分：第一部分是前五行，显示的是整个系统的资源使用状况，我们就是通过这些输出判断服务器的健康状态；第二部分从第六行开始，显示的是系统中进程的信息。</p>
<ul>
<li>我们先来说明第一部分的作用：</li>
</ul>
<p>第一行信息为任务队列信息，具体内容如表所示：</p>
<table>
<thead>
<tr>
<th align="center">内容</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">12:26:46</td>
<td>系统当前时间</td>
</tr>
<tr>
<td align="center">up 1 day, 13:32</td>
<td>系统的运行时间，本机已经运行1天13小时32分钟</td>
</tr>
<tr>
<td align="center">2 users</td>
<td>当前登录了两个用户</td>
</tr>
<tr>
<td align="center">load average: 0.00, 0.00, 0.00</td>
<td>系统在之前1分钟，5分钟，15分钟的平均负载。如果CPU是单核，则这个数超过1，就是高负载。如果CPU是四核，则这个数超过4，就是高负载。（这个平均负载完全是个人经验来进行判断的，一般认为不应该超过服务器CPU的核数。）</td>
</tr>
</tbody></table>
<p>第二行为进程信息，具体内容如表所示：</p>
<table>
<thead>
<tr>
<th align="center">内容</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Tasks:  95 total</td>
<td>系统中的进程总数</td>
</tr>
<tr>
<td align="center">1 running</td>
<td>正在运行的进程数</td>
</tr>
<tr>
<td align="center">94 sleeping</td>
<td>睡眠的进程</td>
</tr>
<tr>
<td align="center">0 stopped</td>
<td>正在停止的进程</td>
</tr>
<tr>
<td align="center">0 zombie</td>
<td>僵尸进程。如果不是0，需要手工检查僵尸进程</td>
</tr>
</tbody></table>
<p>第三行为CPU信息，具体内容如表所示：</p>
<table>
<thead>
<tr>
<th align="center">内容</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Cpu(s):  0.1%us</td>
<td>用户模式占用的CPU百分比</td>
</tr>
<tr>
<td align="center">0.1%sy</td>
<td>系统模式占用的CPU百分比</td>
</tr>
<tr>
<td align="center">0.0%ni</td>
<td>改变过优先级的用户进程占用的CPU百分比</td>
</tr>
<tr>
<td align="center">99.7%id</td>
<td>空闲CPU的CPU百分比</td>
</tr>
<tr>
<td align="center">0.1%wa</td>
<td>等待输入/输出的进程的占用CPU百分比</td>
</tr>
<tr>
<td align="center">0.0%hi</td>
<td>硬中断请求服务占用的CPU百分比</td>
</tr>
<tr>
<td align="center">0.1%si</td>
<td>软中断请求服务占用的CPU百分比</td>
</tr>
<tr>
<td align="center">0.0%st</td>
<td>st（Steal time）虚拟时间百分比。就是当有虚拟机时，虚拟CPU等待实际CPU的时间百分比。</td>
</tr>
</tbody></table>
<p>第四行为物理内存信息，具体内容如表所示：</p>
<table>
<thead>
<tr>
<th align="center">内容</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Mem:    625344k total</td>
<td>物理内存的总量，单位KB</td>
</tr>
<tr>
<td align="center">571504k used</td>
<td>已经使用的物理内存数量</td>
</tr>
<tr>
<td align="center">53840k free</td>
<td>空闲的物理内存数量，我们使用的是虚拟机，总共只分配了628MB内存，所以只有53MB的空闲内存了</td>
</tr>
<tr>
<td align="center">65800k buffers</td>
<td>作为缓冲的内存数量</td>
</tr>
</tbody></table>
<p>第五行为交换分区（swap）信息</p>
<table>
<thead>
<tr>
<th align="center">内容</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Swap:   524280k total</td>
<td>交换分区（虚拟内存）的总大小</td>
</tr>
<tr>
<td align="center">0k used</td>
<td>已经使用的交互分区的大小</td>
</tr>
<tr>
<td align="center">524280k free</td>
<td>空闲交换分区的大小</td>
</tr>
<tr>
<td align="center">409280k cached</td>
<td>作为缓存的交互分区的大小</td>
</tr>
</tbody></table>
<ul>
<li>再来看top命令的第二部分输出，主要是系统进程信息。这部分和ps命令的输出比较类似，只是如果在终端中执行top命令不能看到所有的进程，而只能看到占比靠前的进程。<ul>
<li>PID：进程ID </li>
<li>USER：该进程所属的用户</li>
<li>PR：优先级，数值越小优先级越高</li>
<li>NI：优先级，数值越小优先级越高VIRT：该进程使用的虚拟内存的大小，单位KB </li>
<li>RES：该进程使用的物理内存的大小，单位KB </li>
<li>SHR：共享内存大小，单位KB </li>
<li>S：进程状态</li>
<li>%CPU：该进程占用CPU的百分比</li>
<li>%MEM：该进程占用内存的百分比</li>
<li>TIME+：该进程总共占用的CPU时间</li>
<li>COMMAND：进程的命令名</li>
</ul>
</li>
</ul>
<p>接下来我们举几个top命令常用的实例，来继续说明下top命令。比如我如果只想让top命令查看某一个进程，这时就可以使用“-p选项”：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# top -p 15273</span><br><span class="line">#只查看PID为15273的apache进程</span><br></pre></td></tr></table></figure>

<p>在top命令的交互界面中按“q”键会退出top命令。也可以按“？”或“h”得到top命令交互界面的帮助信息。也可以按“k”键终止某个进程，命令如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# top </span><br><span class="line">top - 14:10:15 up 1 day, 15:15,  3 users,  load average: 0.00, 0.00, 0.00</span><br><span class="line">Tasks:  97 total,   1 running,  96 sleeping,   0 stopped,   0 zombie</span><br><span class="line">Cpu(s):  0.0%us,  0.0%sy,  0.0%ni,100.0%id,  0.0%wa,  0.0%hi,  0.0%si,  0.0%st</span><br><span class="line">Mem:    625344k total,   574248k used,    51096k free,    66840k buffers</span><br><span class="line">Swap:   524280k total,        0k used,   524280k free,   409324k cached PID to kill:15273			#按“k”键，会提示输入要杀死进程的PID</span><br></pre></td></tr></table></figure>

<p>如果在操作终端执行top命令，并不能看到系统中所有的进程，默认看到的只是CPU占比靠前的进程。如果我们想要看到所有的进程可以把top命令的结果重定向到文件当中即可。不过top命令是持续运行的，这时就需要“-b”和“-n”选项了，具体命令如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# top -b -n 1 &gt; &#x2F;root&#x2F;top.log </span><br><span class="line">#让top命令只执行一次，让后把结果保存到top.log文件中。这样就能看到所有的进程了</span><br></pre></td></tr></table></figure>

<p>3）、   pstree命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# pstree [选项]</span><br><span class="line">选项：    </span><br><span class="line">-p：显示进程的PID     </span><br><span class="line">-u：显示进程的所属用户</span><br></pre></td></tr></table></figure>

<h3 id="3、进程的管理"><a href="#3、进程的管理" class="headerlink" title="3、进程的管理"></a>3、进程的管理</h3><p>系统中可以识别的信号较多，我们可以使用命令“kill -l”或“man 7 signal”来查询，命令如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# kill -l </span><br><span class="line">1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL       5) SIGTRAP </span><br><span class="line">6) SIGABRT      7) SIGBUS       8) SIGFPE       9) SIGKILL     10) SIGUSR1</span><br><span class="line">11) SIGSEGV     12) SIGUSR2     13) SIGPIPE     14) SIGALRM     15) SIGTERM</span><br><span class="line">16) SIGSTKFLT   17) SIGCHLD     18) SIGCONT     19) SIGSTOP     20) SIGTSTP</span><br><span class="line">21) SIGTTIN     22) SIGTTOU     23) SIGURG      24) SIGXCPU     25) SIGXFSZ</span><br><span class="line">26) SIGVTALRM   27) SIGPROF     28) SIGWINCH    29) SIGIO       30) SIGPWR</span><br><span class="line">31) SIGSYS      34) SIGRTMIN    35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+3</span><br><span class="line">38) SIGRTMIN+4  39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+8</span><br><span class="line">43) SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+13</span><br><span class="line">48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-12</span><br><span class="line">53) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-7</span><br><span class="line">58) SIGRTMAX-6  59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-2</span><br><span class="line">63) SIGRTMAX-1  64) SIGRTMAX</span><br></pre></td></tr></table></figure>

<p>这里我们介绍一下主要的信号，如表所示：</p>
<table>
<thead>
<tr>
<th>信号代号</th>
<th>信号名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>SIGHUP</td>
<td>该信号让进程立即关闭，然后重新读取配置文件之后重启。</td>
</tr>
<tr>
<td>2</td>
<td>SIGINT</td>
<td>程序终止信号，用于终止前台进程。相当于输出ctrl+c快捷键。</td>
</tr>
<tr>
<td>8</td>
<td>SIGFPE</td>
<td>在发生致命的算术运算错误时发出. 不仅包括浮点运算错误, 还包括溢出及除数为0等其它所有的算术的错误。</td>
</tr>
<tr>
<td>9</td>
<td>SIGKILL</td>
<td>用来立即结束程序的运行. 本信号不能被阻塞、处理和忽略。一般用于强制终止进程。</td>
</tr>
<tr>
<td>14</td>
<td>SIGALRM</td>
<td>时钟定时信号, 计算的是实际的时间或时钟时间. alarm函数使用该信号。</td>
</tr>
<tr>
<td>15</td>
<td>SIGTERM</td>
<td>正常结束进程的信号，kill命令的默认信号。有时如果进程已经发生问题，这个信号是无法正常终止进程的，我们才会尝试SIGKILL信号，也就是信号9。</td>
</tr>
<tr>
<td>18</td>
<td>SIGCONT</td>
<td>该信号可以让暂停的进程恢复执行，本信号不能被阻断。</td>
</tr>
<tr>
<td>19</td>
<td>SIGSTOP</td>
<td>该信号可以暂停前台进程，相当于输入ctrl+z快捷键。本信号不能被阻断。</td>
</tr>
</tbody></table>
<p>3）、   kill命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# kill [信号] PID</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">例2：使用“-1”信号，让进程重启</span><br><span class="line">[root@localhost ~]# kill -1 2246</span><br><span class="line">#使用“-1（数字一）”信号，让httpd的主进程重启动。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">例3：使用“-19”信号，让进程暂停。</span><br><span class="line">[root@localhost ~]# vi test.sh</span><br><span class="line">#使用vi命令编辑一个文件，不要退出</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# ps aux | grep &quot;vi&quot; | grep -v &quot;grep&quot;</span><br><span class="line">root      2313  0.0  0.2   7116  1544 pts&#x2F;1    S+     19:20   0:00 vi test.sh</span><br><span class="line">#换一个不同的终端，查看下这个这个进程的状态。进程状态是S（休眠）和+（位于后台），因为是在另外一个终端运行的命令</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# kill -19 2313</span><br><span class="line">#使用-19信号，让PID是2313的进程暂停。相当于在vi界面按“ctrl+z”快捷键。</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# ps aux | grep &quot;vi&quot; | grep -v &quot;grep&quot;</span><br><span class="line">root      2313  0.0  0.2   7116  1580 pts&#x2F;1   T    19:20   0:00 vi test.sh</span><br><span class="line">#注意2313进程的状态，变成了T（暂停）状态。这时我切换回vi的终端，发现vi命令已经暂停，又回到了命令提示符。不过2313进程就会卡在后台，如果想要恢复可以使用“kill -9 2313”强制终止进程</span><br></pre></td></tr></table></figure>

<p>2）、killall命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# killall [选项][信号] 进程名</span><br><span class="line">选项：    </span><br><span class="line">-i：交互式，询问是否要杀死某个进程    </span><br><span class="line">-I：忽略进程名的大小写</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">交互式杀死sshd进程</span><br><span class="line">[root@localhost ~]# ps aux | grep &quot;sshd&quot;  | grep -v &quot;grep&quot;</span><br><span class="line">root      1733  0.0  0.1   8508  1008 ?        Ss   19:47   0:00 &#x2F;usr&#x2F;sbin&#x2F;sshd</span><br><span class="line">root      1735  0.1  0.5  11452  3296 ?        Ss   19:47   0:00 sshd: root@pts&#x2F;0 </span><br><span class="line">root      1758  0.1  0.5  11452  3296 ?        Ss   19:47   0:00 sshd: root@pts&#x2F;1 </span><br><span class="line">#查询系统有3个sshd进程。1733是sshd服务的进程，1735和1758是我的两个远程连接#的进程。</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# killall -i sshd</span><br><span class="line">#交互式杀死sshd进程</span><br><span class="line">杀死 sshd(1733) ? (y&#x2F;N) n </span><br><span class="line">#这个进程是sshd的服务进程，如果杀死，所有的sshd连接都不能登录。</span><br><span class="line">杀死 sshd(1735) ? (y&#x2F;N) n </span><br><span class="line">#这是我当前登录终端，不能杀死我自己吧！</span><br><span class="line">杀死 sshd(1758) ? (y&#x2F;N) y </span><br><span class="line">#把另外一个sshd登录终端踢出。</span><br></pre></td></tr></table></figure>

<p>3 ）、pkill命令    </p>
<p>pkill命令和killall命令非常类似，也是按照进程名来杀死进程。格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# pkill [选项] [信号] 进程名</span><br><span class="line">选项：    </span><br><span class="line">-t 终端号：按照终端号踢出用户</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# pkill -9 -t pts&#x2F;1</span><br><span class="line">#强制杀死从pts&#x2F;1虚拟终端登录的进程</span><br></pre></td></tr></table></figure>

<h2 id="二、工作管理"><a href="#二、工作管理" class="headerlink" title="二、工作管理"></a>二、工作管理</h2><h3 id="1、工作管理简介"><a href="#1、工作管理简介" class="headerlink" title="1、工作管理简介"></a>1、工作管理简介</h3><p>后台管理有几个事项需要大家注意：</p>
<ul>
<li>前台是指当前可以操控和执行命令的这个操作环境，后台是指工作可以自行运行，但是不能直接用ctrl+c来终止它，只能使用fg/bg来调用工作；</li>
<li>当前的登录终端，只能管理当前终端的工作，而不能管理其他登录终端的工作。如tty1登录的终端是不能管理tty2终端中的工作的；</li>
<li>放入后台的命令必须可以持续运行一段时间，这样我们才能扑捉和操作这个工作。如果把ls命令放入后台执行，它很快就会执行完成，我们很难操作它。</li>
<li>放入后台执行的命令不能和前台用户有交互或需要前台输入，否则放入后台只能暂停，而不能执行。比如vi命令放入后台只能暂停，而不能执行，因为vi需要前台输入信息。top命令也不能放入后台执行，而只能放入后台暂停，因为top命令需要和前台有交互。</li>
</ul>
<h3 id="2、如何把命令放入后台"><a href="#2、如何把命令放入后台" class="headerlink" title="2、如何把命令放入后台"></a>2、如何把命令放入后台</h3><p>那么我们如何把命令放入后台呢？有两种方法，分别如下：    </p>
<p>1)、第一种方法是“命令 &amp;”，把命令放入后台执行</p>
<p>第一种把命令放入后台的方法是在命令后面加入“空格&amp;”，这种方法放入后台的命令，在后台是执行状态。但是注意，放入后台执行的命令不能与前台有交互，否则这个命令是不能在后台执行的。</p>
<p>举个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# find &#x2F; -name install.log &amp;</span><br><span class="line">[1] 1920</span><br><span class="line"># [工作号] 进程号</span><br><span class="line">#find命令放入后台执行，每个后台命令会分配一个工作号，命令既然可以执行，就会有进程产生，所以也会有进程号。</span><br></pre></td></tr></table></figure>

<p>这样的话，虽然find命令在执行，但是当前终端我还是可以进行其他命令操作的。如果在终端上出现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1]+  Done                    find &#x2F; -name install.log</span><br></pre></td></tr></table></figure>

<p>证明后台这个任务已经完成了，当然命令如果有执行结果的话，也会显示到操作终端上。[1]是这个命令的工作号，+号代表这个任务是最近一个被放入后台的工作。    </p>
<p>2)、第二种方法是在命令执行过程中按ctrl+z快捷键，命令在后台是暂停状态</p>
<p>使用这种方法放入后台的命令，就算是不和前台有交互，能在后台执行的命令，也是暂停状态，ctrl+z快捷键就是暂停的快捷键。举几个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">例1：</span><br><span class="line">[root@localhost ~]# top</span><br><span class="line">#在top命令执行的过程中，按下ctrl+z快捷键</span><br><span class="line">[1]+  Stopped                 top</span><br><span class="line">#提示命令被放入后台，工作号是1，状态是暂停。而且虽然top命令没有结束，也能取得控制台权限。</span><br><span class="line"></span><br><span class="line">例2：</span><br><span class="line">[root@localhost ~]# tar -zcf etc.tar.gz &#x2F;etc</span><br><span class="line">#压缩一下&#x2F;etc&#x2F;目录</span><br><span class="line">tar: 从成员名中删除开头的“&#x2F;” </span><br><span class="line">tar: 从硬连接目标中删除开头的“&#x2F;” </span><br><span class="line">^Z                         #执行的过程中，按下ctrl+z快捷键</span><br><span class="line">[2]+  Stopped                 tar -zcf etc.tar.gz &#x2F;etc</span><br><span class="line">#命令被放入后台，工作号是2，状态是暂停。</span><br></pre></td></tr></table></figure>

<h3 id="3、后台命令管理"><a href="#3、后台命令管理" class="headerlink" title="3、后台命令管理"></a>3、后台命令管理</h3><p>1）、查看后台的工作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# jobs </span><br><span class="line">[-l]选项：    </span><br><span class="line">-l：显示工作的PID</span><br></pre></td></tr></table></figure>

<p>2）、将后台暂停的工作恢复到前台执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# fg %工作号</span><br><span class="line">参数：    </span><br><span class="line">%工作号：   %号可以省略，但是注意工作号和PID的区别</span><br></pre></td></tr></table></figure>

<p>3）、把后台暂停的工作恢复到后台执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# bg %工作号</span><br></pre></td></tr></table></figure>

<p>4）、后台命令脱离登录终端运行</p>
<p>我们已经知道把命令放入后台，只能在当前登录终端执行。那如果我是远程管理的服务器，在远程终端中执行了后台命令，这时我退出登录，这个后台命令还能继续执行吗？当然是不行的，这个后台命令会被终止。但是我们确实需要在远程终端中执行某些后台命令，该如何执行呢？</p>
<ul>
<li><p>第一种方法是把需要后台执行的命令加入/etc/rc.local文件，让系统在启动时执行这个后台程序。这种方法的问题是，服务器时不能随便重启的，万一有临时后台任务，就不能执行。</p>
</li>
<li><p>第二种方法是使用系统定时任务，让系统在指定的时间执行某个后台命令。这样放入后台的命令与终端无关，是不依赖登录终端的。</p>
</li>
<li><p>最后一种方法是使用nohup命令。    </p>
<p>nohup命令的作用就是让后台工作在离开操作终端时，也能够正确的在后台执行。命令的格式如下：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# nohup [命令] &amp; </span><br><span class="line">例如：</span><br><span class="line">[root@localhost ~]# nohup find &#x2F; -print &gt; &#x2F;root&#x2F;file.log &amp;  </span><br><span class="line">[3] 2349				#用find命令，打印&#x2F;下所有文件。放入后台执行</span><br><span class="line">[root@localhost ~]# nohup</span><br><span class="line">#忽略输入并把输出追加到&quot;nohup.out&quot;</span><br><span class="line">#有提示信息</span><br></pre></td></tr></table></figure>

<h2 id="三、系统资源查看"><a href="#三、系统资源查看" class="headerlink" title="三、系统资源查看"></a>三、系统资源查看</h2><h3 id="1、vmstat命令监控系统资源"><a href="#1、vmstat命令监控系统资源" class="headerlink" title="1、vmstat命令监控系统资源"></a>1、vmstat命令监控系统资源</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vmstat [刷新延时刷新次数] </span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line">[root@localhost proc]# vmstat 1 3</span><br><span class="line">#使用vmstat检测，每1秒刷新一次，共刷新3次</span><br><span class="line">procs -----------memory---------- --- swap  -- -----io----   --system-- -----cpu-----  </span><br><span class="line">r  b   swpd   free   buff  cache   si   so    bi    bo    in   cs us sy id wa st  </span><br><span class="line">0  0      0 407376  55772  84644    0    0     5     2    9   10  0  0 100  0  0 </span><br><span class="line">0  0      0 407368  55772  84644    0    0     0     0   12   10  0  0 100  0  0 </span><br><span class="line">0  0      0 407368  55772  84644    0    0     0     0   15   13  0  0 100  0  0</span><br></pre></td></tr></table></figure>

<p>解释下这个命令的输出：</p>
<ul>
<li><p>procs：进程信息字段：</p>
<ul>
<li>r：等待运行的进程数，数量越大，系统越繁忙。</li>
<li>b：不可被唤醒的进程数量，数量越大，系统月繁忙。</li>
</ul>
</li>
<li><p>memory：内存信息字段：</p>
<ul>
<li>swpd：虚拟内存的使用情况，单位KB。</li>
<li>free：空闲的内存容量，单位KB。</li>
<li>buff：缓冲的内存容量，单位KB。</li>
<li>cache：缓存的内存容量，单位KB。</li>
</ul>
</li>
<li><p>swap：交换分区的信息字段：</p>
<ul>
<li>si：从磁盘中交换到内存中数据的数量，单位KB。</li>
<li>so：从内存中交换到磁盘中数据的数量，单位KB。此两个数越大，证明数据需要经常在磁盘和内存之间交换，系统性能越差。</li>
</ul>
</li>
<li><p>io：磁盘读写信息字段：</p>
<ul>
<li>bi：从块设备读入数据的总量，单位是块。</li>
<li>bo：写到块设备的数据的总量，单位是块。此两个数越大，代表系统的I/O越繁忙。</li>
</ul>
</li>
<li><p>system：系统信息字段：</p>
<ul>
<li>in：每秒被中断的进程次数。</li>
<li>cs：每秒钟进行的事件切换次数。此两个数越大，代表系统与接口设备的通信非常繁忙。</li>
</ul>
</li>
<li><p>CPU：CPU信息字段：</p>
<ul>
<li>us：非内核进程消耗CPU运算时间的百分比。</li>
<li>sy：内核进程消耗CPU运算时间的百分比。</li>
<li>id：空闲CPU的百分比。</li>
<li>wa：等待I/O所消耗的CPU百分比。</li>
<li>st：被虚拟机所盗用的CPU占比。</li>
</ul>
</li>
</ul>
<h3 id="2、dmesg显示开机时内核检测信息"><a href="#2、dmesg显示开机时内核检测信息" class="headerlink" title="2、dmesg显示开机时内核检测信息"></a>2、dmesg显示开机时内核检测信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例如：</span><br><span class="line">[root@localhost ~]# dmesg | grep CPU</span><br><span class="line">#查看CPU信息</span><br><span class="line">[root@localhost ~]# dmesg | grep eth0</span><br><span class="line">#查询第一块网卡信息</span><br></pre></td></tr></table></figure>

<h3 id="3、free命令查看内存使用状态"><a href="#3、free命令查看内存使用状态" class="headerlink" title="3、free命令查看内存使用状态"></a>3、free命令查看内存使用状态</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# free [-b|-k|-   m|-g] </span><br><span class="line">选项：    </span><br><span class="line">-b：以字节为单位显示    </span><br><span class="line">-k：以KB为单位显示，默认就是以KB为单位显示    </span><br><span class="line">-m：以MB为单位显示    </span><br><span class="line">-g：以GB为单位显示</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# free               </span><br><span class="line">			total       used       free     shared    buffers     cached</span><br><span class="line">Mem:        625344     219704     405640          0      56852      85276</span><br><span class="line">-&#x2F;+ buffers&#x2F;cache:      77576     547768</span><br><span class="line">Swap:       524280          0     524280</span><br></pre></td></tr></table></figure>

<p>解释下这个命令：</p>
<p>第一行：total是总内存数，used是已经使用的内存数，free是空闲的内存数，shared是多个进程共享的内存总数，buffers是缓冲内存数，cached是缓存内存数。默认单位是KB。</p>
<p>第二行：-/buffers/cache的内存数，相当于第一行的used-buffers-cached。+/buffers/cache的内存数，相当于第一行的free+buffers+cached。</p>
<p>第三行：total是swap的总数；used是已经使用的swap数，free是空闲的swap数。默认单位是KB。</p>
<h3 id="4、查看CPU信息"><a href="#4、查看CPU信息" class="headerlink" title="4、查看CPU信息"></a>4、查看CPU信息</h3><p>CPU的主要信息保存在/proc/cpuinfo这个文件当中，我们只要查看这个文件，就可以知道cpu的相关信息。命令如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cat &#x2F;proc&#x2F;cpuinfo </span><br><span class="line">processor       : 0</span><br><span class="line">#逻辑CPU编号</span><br><span class="line">vendor_id       : GenuineIntel</span><br><span class="line">#CPU制造厂商</span><br><span class="line">cpu family      : 6</span><br><span class="line">#产品的系列代号</span><br><span class="line">model           : 58</span><br><span class="line">#CPU系列代号</span><br><span class="line">model name      : Intel(R) Core(TM) i7-3630QM CPU @ 2.40GHz</span><br><span class="line">#CPU系列的名字，编号，主频</span><br><span class="line">stepping        : 9</span><br><span class="line">#更新版本</span><br><span class="line">cpu MHz         : 2394.649</span><br><span class="line">#实际主频</span><br><span class="line">cache size      : 6144 KB </span><br><span class="line">#二级缓存</span><br></pre></td></tr></table></figure>

<h3 id="5、查看本机登陆用户信息"><a href="#5、查看本机登陆用户信息" class="headerlink" title="5、查看本机登陆用户信息"></a>5、查看本机登陆用户信息</h3><p>如果我们想要知道Linux服务器上目前已经登录的用户信息，可以使用w或who命令来进行查询。先看看w命令，命令格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# w </span><br><span class="line">09:54:22 up  9:50,  2 users,  load average: 0.00, 0.00, 0.00</span><br><span class="line">USER     TTY      FROM              LOGIN@   IDLE   JCPU   PCPU WHAT</span><br><span class="line">root     tty1     -                09:53   57.00s  0.02s  0.02s -bash</span><br><span class="line">root     pts&#x2F;0    192.168.0.108    09:53    0.00s  0.09s  0.06s w</span><br></pre></td></tr></table></figure>

<p>解释下这个命令的结果：</p>
<ul>
<li>第一行其实和top命令的第一行非常类似，主要显示了系统当前时间，开机多久（up），有多少用户登陆（users），1分钟、5分钟、15分钟前的平均负载（load average）。</li>
<li>第二行是项目的说明，第三行开始每行代表一个用户。这些项目是：<ul>
<li>USER：登陆的用户名；</li>
<li>TTY：登陆终端；</li>
<li>FROM：从哪个IP地址登陆；</li>
<li>LOGIN@：登陆时间；</li>
<li>IDLE：用户闲置时间；</li>
<li>JCPU：指的是和该终端连接的所有进程占用的CPU运算时间。这个时间里并不包括过去的后台作业时间，但却包括当前正在运行的后台作业所占用的时间；</li>
<li>PCPU：  是指当前进程所占用的CPU运算时间；</li>
<li>WHAT：当前正在运行的命令。    </li>
</ul>
</li>
</ul>
<p>who命令比w命令稍微简单一点，也可以用来查看系统中已经登录的用户。命令如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# who</span><br><span class="line">root     tty1         2018-06-07 09:53</span><br><span class="line">root     pts&#x2F;0        2018-06-07 09:53 (192.168.0.108)</span><br><span class="line">#用户名	登录终端		登录时间（登录来源IP地址）</span><br></pre></td></tr></table></figure>

<h3 id="6、uptime命令"><a href="#6、uptime命令" class="headerlink" title="6、uptime命令"></a>6、uptime命令</h3><p>uptime命令的作用就是显示系统的启动时间和平均负载，也就是top命令的第一行。其实w命令也能看到这一行的数据，具体原意使用哪个命令看个人习惯。命令如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# uptime  </span><br><span class="line">10:56:30 up 10:52,  2 users,  load average: 0.00, 0.00, 0.00</span><br></pre></td></tr></table></figure>

<h3 id="7、查看系统与内核相关信息"><a href="#7、查看系统与内核相关信息" class="headerlink" title="7、查看系统与内核相关信息"></a>7、查看系统与内核相关信息</h3><p>我们使用uname命令查看内核的相关信息，命令如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# uname [选项] </span><br><span class="line">选项：    </span><br><span class="line">-a：查看系统所有相关信息；    </span><br><span class="line">-r：查看内核版本；    </span><br><span class="line">-s：查看内核名称。</span><br></pre></td></tr></table></figure>

<p>如果我们想要判断当前系统的位数，可以通过file命令来判断系统文件（主要是系统命令）的位数来推断系统的位数。命令如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# file &#x2F;bin&#x2F;ls</span><br><span class="line">&#x2F;bin&#x2F;ls: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked (uses shared libs), for GNU&#x2F;Linux 2.6.18, stripped</span><br><span class="line">#很明显，当前系统是32位的。</span><br></pre></td></tr></table></figure>

<p>如果我们想要查询当前Linux系统的发行版本，可以使用“lsb_release -a”命令查看，命令如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# lsb_release -a</span><br></pre></td></tr></table></figure>

<h2 id="四、系统定时任务"><a href="#四、系统定时任务" class="headerlink" title="四、系统定时任务"></a>四、系统定时任务</h2><h3 id="1、at一次性执行定时任务"><a href="#1、at一次性执行定时任务" class="headerlink" title="1、at一次性执行定时任务"></a>1、at一次性执行定时任务</h3><p>1)、    at服务管理与访问控制    </p>
<p>at命令要想正确执行，需要atd服务的支持。atd服务是独立的服务，所以启动的命令是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# service atd start </span><br><span class="line">正在启动 atd：                                             [确定]</span><br></pre></td></tr></table></figure>

<p>如果想要让atd服务开机时自动启动，可以使用如下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# chkconfig atd on</span><br></pre></td></tr></table></figure>

<p>atd服务启动之后，at命令才可以正常使用，不过我们还要学习下at命令的访问控制。这里的访问控制指的是允许哪些用户使用at命令设定定时任务，或者不允许哪些用户使用at命令。大家可以想象成为设定黑名单或设定白名单，这样更容易理解。at的访问控制是依靠/etc/at.allow文 件（ 白名单）和/etc/at.deny文件（黑名单）这两个文件来实现的，具体规则如下：</p>
<ul>
<li>如果系统中有/etc/at.allow文件，那么只有写入/etc/at.allow文件（白名单）中的用户可以使用at命令，其他用户不能使用at命令（/etc/at.deny文件会被忽略，也就是说同一个用户既写入/etc/at.allow文件，也写入/etc/at.deny文件，那么这个用户是可以使用at命令的，因为/etc/at.allow文件优先级更高。）。</li>
<li>如果系统中没有/etc/at.allow文件，只有/etc/at.deny文件，那么写入/etc/at.deny文件（黑名单）中的用户不能使用at命令，其他用户可以使用at命令。不过这个文件对root用户不生效。</li>
<li>如果系统中这两个文件都不存在，那么只有root用户可以使用at命令。</li>
</ul>
<p>系统中默认时只有/etc/at.deny文件，而且这个文件是空的，这样的话系统中所有的用户都可以使用at命令。不过如果我们打算控制用户的at命令权限，把用户写入/etc/at.deny文件即可</p>
<p>/etc/at.allow文件的权限更高，如果/etc/at.allow文件存在，则/etc/at.deny文件失效。/etc/at.allow管理行为更加严格，因为只有写入这个文件的用户才能使用at命令，如果需要禁用at命令的用户较多，则可以把少数用户写入这个文件。/etc/at.deny文件的管理较为松散，如果允许使用at命令的用户较多，则可以把禁用的用户写入这个文件。不过这两个文件都不能对root用户生效。    </p>
<p>2）、at命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# at [选项] 时间</span><br><span class="line">选项：    </span><br><span class="line">	-m：当at工作完成后，无论是否命令有输出，都用email通知执行at    命令的用户    </span><br><span class="line">	-c 工作号：显示该at工作的实际内容</span><br><span class="line">时间：    </span><br><span class="line">	at支持的时间格式如下：    </span><br><span class="line">	HH:MM在指定的“小时:分钟”执行命令，例如：02:30    </span><br><span class="line">	HH:MM YYYY-MM-   DD 在指定的“小时:分钟年-月-日”执行，例如02:30 2018-07-25     </span><br><span class="line">	HH:MM[am|pm] [month] [date] 在指定的“小时:分钟[上午|下午][月][日]”执行，例如02:30 July 25    </span><br><span class="line">	HH:MM[am|pm] + [minutes|hours|days|weeks]在指定的时间“再加多久执行”，例如now + 5 minutes，05am +2 hours</span><br></pre></td></tr></table></figure>

<p>at命令只要指定正确的时间，就可以输入需要在指定时间执行的命令了，这个命令可以是系统命令，也可以是shell脚本。举几个例子吧：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">例子1：</span><br><span class="line">[root@localhost ~]# cat &#x2F;root&#x2F;hello.sh </span><br><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">echo &quot;hello world!&quot;</span><br><span class="line">#该脚本会打印“hello workd!”</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# at now +2 minutes</span><br><span class="line">at&gt; &#x2F;root&#x2F;hello.sh &gt;&gt; &#x2F;root&#x2F;hello.log</span><br><span class="line">#执行hello.sh脚本，并把输出写入&#x2F;root&#x2F;hello.log文件</span><br><span class="line">at&gt; &lt;EOT&gt;						#使用ctrl+d保存at任务</span><br><span class="line">job 8 at 2018-07-25 20:54		#这是第8个at任务，会在2018年7月25日20:54分执行</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# at -c 8  </span><br><span class="line">#查询第8个at任务的内容</span><br><span class="line">...省略部分内容... 	#主要是定义系统的环境变量</span><br><span class="line">&#x2F;root&#x2F;hello.sh &gt;&gt; &#x2F;root&#x2F;hello.log</span><br><span class="line">#可以看到at执行的任务</span><br><span class="line"></span><br><span class="line">例子2：</span><br><span class="line">[root@localhost ~]# at 02:00 2018-07-26 </span><br><span class="line">at&gt; &#x2F;bin&#x2F;sync</span><br><span class="line">at&gt; &#x2F;sbin&#x2F;shutdown -h now </span><br><span class="line">at&gt; &lt;EOT&gt;</span><br><span class="line">job 9 at 2018-07-26 02:00</span><br><span class="line">#在指定的时间关机。在一个at任务中，是可以执行多个系统命令的</span><br></pre></td></tr></table></figure>

<p>3）、其他at管理命令    </p>
<p>at还有查询和删除命令，命令如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# atq </span><br><span class="line">#查询当前服务器上的at工作</span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line">[root@localhost ~]# atq  </span><br><span class="line">9       2018-07-26 02:00 a root</span><br><span class="line">#说明root用户有一个at任务在2018年7月26日的02:00执行，工作号是9 </span><br><span class="line"></span><br><span class="line">[root@localhost ~]# atrm [工作号] </span><br><span class="line">#删除指定的at任务</span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line">[root@localhost ~]# atrm 9</span><br><span class="line">[root@localhost ~]# atq</span><br><span class="line">#删除9号at任务，再查询就没有at任务存在了</span><br></pre></td></tr></table></figure>

<h3 id="2、crontab循环执行定时任务"><a href="#2、crontab循环执行定时任务" class="headerlink" title="2、crontab循环执行定时任务"></a>2、crontab循环执行定时任务</h3><p>1）、   crond服务管理与访问控制    </p>
<p>crontab命令是需要crond服务支持的，crond服务同样是独立的服务，所以启动和自启动方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# service crond restart</span><br><span class="line">停止 crond：                                               [确定] </span><br><span class="line">正在启动 crond：              							   [确定] </span><br><span class="line">#重启动crond服务</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# chkconfig crond on</span><br><span class="line">#设定crond服务为开机自启动</span><br></pre></td></tr></table></figure>

<p>crond服务默认是自启动的，如果服务器上有循环执行的系统定时任务，就不要关闭crond服务了。    </p>
<p>crontab命令和at命令类似，也是通过/etc/cron.allow和/etc/cron.deny文件来限制某些用户是否可以使用crontab命令的。而且原则也非常相似：</p>
<ul>
<li>当系统中有/etc/cron.allow文件时，只有希尔此文件的用户可以使用crontab命令，没有写入的用户不能使用crontab命令。同样如果有此文件，/etc/cron.deny文件会被忽略，/etc/cron.allow文件的优先级更高。</li>
<li>当系统中只有/etc/cron.deny文件时，则写入此文件的用户不能使用crontab命令，没有写入文件的用户可以使用crontab命令。</li>
</ul>
<p>这个规则基本和at的规则一直，同样/etc/cron.allow文件的优先级比/etc/cron.deny文件的优先级高，Linux中默认只有/etc/cron.deny文件。    </p>
<p>2）、用户的crontab设置</p>
<p>每个用户都可以实现自己的crontab定时任务，只要是使用这个用户身份执行“crontab -e”命令即可，当然这个用户不能加入/etc/cron.deny文件中。crontab命令格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# crontab [选项] </span><br><span class="line">选项：    </span><br><span class="line">-e：编辑crontab定时任务    </span><br><span class="line">-l：查询crontab任务    </span><br><span class="line">-r：删除当前用户所有的crontab任务，如果有多个任务，只想删除一个，可以所以用“crontab -e”       </span><br><span class="line">-u 用户名：修改或删除其他用户的crontab任务。只有root可用</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# crontab -e </span><br><span class="line">#进入crontab编辑界面。会打开vim编辑你的工作。</span><br><span class="line">* * * * * 执行的任务</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>项目</th>
<th>含义</th>
<th>范围</th>
</tr>
</thead>
<tbody><tr>
<td>第一个“*”</td>
<td>一小时当中的第几分钟</td>
<td>0-59</td>
</tr>
<tr>
<td>第二个“*”</td>
<td>一天当中的第几小时</td>
<td>0-23</td>
</tr>
<tr>
<td>第三个“*”</td>
<td>一个月当中的第几天</td>
<td>1-31</td>
</tr>
<tr>
<td>第四个“*”</td>
<td>一年当中的第几月</td>
<td>1-12</td>
</tr>
<tr>
<td>第五个“*”</td>
<td>一周当中的星期几</td>
<td>0-7（0和7都代表星期日）</td>
</tr>
</tbody></table>
<p>在时间表示时，还有一些特殊符号需要学习，如表所示：</p>
<table>
<thead>
<tr>
<th>特殊符号</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>*</td>
<td>代表任何时间。比如第一个“*”就代表一小时中每分钟都执行一次的意思。</td>
</tr>
<tr>
<td>，</td>
<td>代表不连续的时间。比如“0 8,12,16 * * * 命令”，就代表在每天的8点0分，12点0分，16点0分都执行一次命令</td>
</tr>
<tr>
<td>-</td>
<td>代表连续的时间范围。比如“0 5 * * 1-6命令”，代表在周一到周六的凌晨5点0分执行命令</td>
</tr>
<tr>
<td>*/n</td>
<td>代表每隔多久执行一次。比如“*/10 * * * * 命令”，代表每隔10分钟就执行一遍命令</td>
</tr>
</tbody></table>
<p>举例</p>
<table>
<thead>
<tr>
<th>时间</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>45 22 * * * 命令</td>
<td>在22点45分执行命令</td>
</tr>
<tr>
<td>0 17 * * 1 命令</td>
<td>每周1 的17点0分执行命令</td>
</tr>
<tr>
<td>0 5 1,15 * * 命令</td>
<td>每月1号和15号的凌晨5点0分执行命令</td>
</tr>
<tr>
<td>40 4 * * 1-5 命令</td>
<td>每周一到周五的凌晨4点40分执行命令</td>
</tr>
<tr>
<td>*/10 4 * * * 命令</td>
<td>每天的凌晨4点，每隔10分钟执行一次命令</td>
</tr>
<tr>
<td>0 0 1,15 * 1 命令</td>
<td>每月1号和15号，每周1的0点0分都会执行命令。注意：星期几和几号最好不要同时出现，因为他们定义的都是天。非常容易让管理员混乱。</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">例子1：让系统每隔5分钟，就向&#x2F;tmp&#x2F;test文件中写入一行“11”，验证一下系统定时任务是否会执行</span><br><span class="line">[root@localhost ~]# crontab -e </span><br><span class="line">#进入编辑界面</span><br><span class="line">*&#x2F;5 * * * * &#x2F;bin&#x2F;echo ”11” &gt;&gt; &#x2F;tmp&#x2F;test</span><br><span class="line"></span><br><span class="line">例子2：在系统在每周二的凌晨5点05分重启一次</span><br><span class="line">[root@localhost ~]# crontab -e </span><br><span class="line">5 5 * * 2 &#x2F;sbin&#x2F;shutdown -r now</span><br><span class="line"></span><br><span class="line">例子3：在每月的1号，10号，15号的凌晨3点30分都定时执行日志备份脚本autobak.sh</span><br><span class="line">[root@localhost ~]# crontab -e </span><br><span class="line">30 3 1,10,15 * * &#x2F;root&#x2F;sh&#x2F;autobak.sh</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# crontab -l </span><br><span class="line">#查看root用户的crontab任务</span><br><span class="line">[root@localhost ~]# crontab -r </span><br><span class="line">#删除root用户所有的定时任务，如果只想删除某一个定时任务，</span><br><span class="line">#可以“crontab -e”进入编辑模式手工删除</span><br></pre></td></tr></table></figure>

<p>3）、   crontab的注意事项</p>
<p>在书写crontab定时任务时，需要注意几个注意事项，这里我们再强调下：</p>
<ul>
<li>六个选项都不能为空，必须填写。如果不确定使用“*”代表任意时间；</li>
<li>crontab定时任务，最小有效时间是分钟，最大时间范围是月。像2018年某时执行，3点30分30秒这样的时间都不能识别；</li>
<li>在定义时间时，日期和星期最好不要在一条定时任务中出现，因为它们都是以天作为单位，非常容易让管理员混乱；</li>
<li>在定时任务中，不管是直接写命令，还是在脚本中写命令，最好都是用绝对路径。有时相对路径的命令会报错。   </li>
</ul>
<p>4、系统的crontab设置</p>
<p>“crontab -e”是每个用户执行的命令，也就是说不同的用户身份可以执行自己的定时任务。可是有些定时任务需要系统执行，这时我们就需要编辑/etc/crontab这个配置文件了。当然，并不是说写入/etc/crontab配置文件中的定时任务执行时，不需要用户身份，而是“crontab -e”命令定义定时任务时，默认用户身份是当前登录用户。而修改/etc/crontab配置文件时，定时任务的执行着身份是可以手工指定的。这样定时任务的执行会更加灵活，修改起来也更加方便。</p>
<p>那我们打开这个文件看看吧：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vi &#x2F;etc&#x2F;crontab</span><br><span class="line">SHELL&#x3D;&#x2F;bin&#x2F;bash</span><br><span class="line">#标示使用哪种shell </span><br><span class="line">PATH&#x3D;&#x2F;sbin:&#x2F;bin:&#x2F;usr&#x2F;sbin:&#x2F;usr&#x2F;bin</span><br><span class="line">#指定PATH环境变量，crontab是使用自己的PATH，而不是用系统默认的，所以在定时任务中出现的命令最好使用大写</span><br><span class="line">MAILTO&#x3D;root</span><br><span class="line">#如果有报错输出，或命令结果又输出，会向root发信息</span><br><span class="line">HOME&#x3D;&#x2F;</span><br><span class="line">#标示主目录</span><br><span class="line"></span><br><span class="line"># For details see man 4 crontabs</span><br><span class="line">#提示大家可以去“man 4 crontabs”查看帮助</span><br><span class="line"></span><br><span class="line"># Example of job definition:</span><br><span class="line"># .---------------- minute (0 - 59) </span><br><span class="line"># |  .------------- hour (0 - 23)  </span><br><span class="line"># |  |  .---------- day of month (1 - 31)  </span><br><span class="line"># |  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ...</span><br><span class="line"># |  |  |  |  .---- day of week (0 - 6) (Sunday&#x3D;0 or 7) OR sun,mon,tue,wed,thu,fri,sat</span><br><span class="line"># |  |  |  |  |</span><br><span class="line"># *  *  *  *  * user-name command to be executed </span><br><span class="line">#分时日月周执行者身份命令</span><br><span class="line">#列出文件格式，并加入了注释</span><br></pre></td></tr></table></figure>

<p>在CentOS 6.x中，/etc/crontab这个文件也发生了变化，在CentOS 5.x中这个文件的内容大概是这个样子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#以下输出，是在CentOS 5.5当中</span><br><span class="line">[root@sc ~]# vi &#x2F;etc&#x2F;crontab </span><br><span class="line">SHELL&#x3D;&#x2F;bin&#x2F;bash</span><br><span class="line">PATH&#x3D;&#x2F;sbin:&#x2F;bin:&#x2F;usr&#x2F;sbin:&#x2F;usr&#x2F;bin</span><br><span class="line">MAILTO&#x3D;root</span><br><span class="line">HOME&#x3D;&#x2F;</span><br><span class="line"></span><br><span class="line"># run-parts</span><br><span class="line">01 * * * * root run-parts &#x2F;etc&#x2F;cron.hourl</span><br><span class="line">02 4 * * * root run-parts &#x2F;etc&#x2F;cron.daily</span><br><span class="line">22 4 * * 0 root run-parts &#x2F;etc&#x2F;cron.weekly</span><br><span class="line">42 4 1 * * root run-parts &#x2F;etc&#x2F;cron.monthly</span><br></pre></td></tr></table></figure>

<p>在CentOS  5.x版本中，/etc/crontab文件会使用run-parts脚本执行/etc/cron.{daily,weekly,monthly}目录中的所有文件。这个run-parts其实是一个shell脚本，保存在/usr/bin/run-parts，它的作用就是把其后面跟随的目录中的所有可执行文件依次执行。也就是说，如果我们想让某个脚本在每天都执行一次，可以不用手工去写定时任务，而只需要给这个脚本赋予执行权限，并把它放入/etc/cron.daily/目录中。这样这个脚本就会在每天的凌晨4点02分执行了。</p>
<p>可是在CentOS 6.x版本中，/etc/crontab文件中不再有相关的段落，那么是否run-   ptars这种定时任务执行方法不可用了呢？我们看到/etc/crontab中有一句提示，让我们“man 4 crontabs”来查看帮助，那么我们就看看这个帮助吧！在这个帮助中，明确写明了“在旧版本的crontab配置文件中，是通过run -parts脚本来调用cron.{daily,weekly,monthly}目录，定时执行这些目录中的脚本。在当前系统中，为了避免cron和anacron之间产生冲突，只要anacron已经安装，就使用anacron来执行这些目录中的脚本。具体可以查看anacron（8）的帮助。”。对于anacron的用法，我们下一个小节来介绍。</p>
<p>其实对我们用户来讲，我们并不需要知道这个定时任务到底是由哪个程序调用的。我们需要知道的事情是如何使用系统的crontab设置。这个新老版本的CentOS没有区别，配置方法都有两种：</p>
<ul>
<li>第一种方法就是我刚刚说过的，把你需要定时执行的工作写成脚本程序，并赋予执行权限，然后直接把这个脚本复制到/etc/cron.{daily,weekly,monthly}目录中的任意一个。比如我需要让某个脚本每周执行，那么就把这个脚本复制到/etc/cron.weekly/目中中。这样这个脚本就会每周执行一次，具体的执行时间要参考anacron的配置。</li>
<li>第二种方法就是修改/etc/crontab这个配置文件，自己加入自己的定时任务，不过需要注意指定脚本的执行者身份。例如：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vi &#x2F;etc&#x2F;crontab</span><br><span class="line">...省略部分输出... </span><br><span class="line">* * * * * root run-parts &#x2F;root&#x2F;cron&#x2F;</span><br><span class="line">#让系统每分钟都执行一次&#x2F;root&#x2F;cron&#x2F;目录中的脚本，脚本执行者是root用户。</span><br><span class="line">#虽然在CentOS 6.x中，不是直接通过此配置文件调用&#x2F;etc&#x2F;cron.&#123;daily,weekly,monthly&#125;这些目录，但是run-   parts脚本还是可以使用的。所以我完全可以参照CentOS 5.x的方法来写定时任务。</span><br><span class="line">#使用run-   parts脚本调用并执行&#x2F;root&#x2F;cron&#x2F;目录中所有的可执行文件</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# mkdir cron</span><br><span class="line">#建立&#x2F;root&#x2F;cron目录</span><br><span class="line">[root@localhost cron]# vi &#x2F;root&#x2F;cron&#x2F;hello.sh</span><br><span class="line">#&#x2F;bin&#x2F;bash</span><br><span class="line">echo &quot;hello&quot; &gt;&gt; &#x2F;root&#x2F;cron&#x2F;hello.log</span><br><span class="line">#在&#x2F;root&#x2F;cron&#x2F;hello.log文件中写入hello </span><br><span class="line">[root@localhost cron]# chmod 755 hello.sh</span><br><span class="line">#赋予执行权限。</span><br><span class="line">#因为hello.sh脚本放入了&#x2F;root&#x2F;cron&#x2F;目录，所以会每分钟执行一次。</span><br></pre></td></tr></table></figure>

<p>只要保存/etc/crontab文件，这个定时任务就可以执行了，当然要确定crond服务是运行的。这两种方法都是可以使用的，具体看个人的习惯吧！不过要想修改/etc/crontab文件，当然我要是root用户才可以，普通不能修改，只能使用用户身份的crontab命令。</p>
<h3 id="3、anacron"><a href="#3、anacron" class="headerlink" title="3、anacron"></a>3、anacron</h3><p>anacron是用来干什么的呢？我们的Linux服务器如果不是24小时开机的，那么刚好在关机的时间段之内有系统定时任务（cron）需要执行，那么这些定时任务是不会执行的。也就是说，假设我们需要在凌晨5点05分执行系统的日志备份，但是我们的Linux服务器不是24小时开机的，在晚上需要关机，白天上班之后才会再次开机。这个定时任务的执行时间我们的服务器刚好没有开机，那么这个任务就不会执行了。anacron就是用来解决这个问题的。    </p>
<p>anacron会使用一天，七天，一个月作为检测周期，用来判断是否有定时任务在关机之后没有执行，如果有这样的任务，anacron会在特定的时间重新执行这些定时任务。那么anacron是如何判断这些定时任务已经超过了执行时间呢？在系统的/var/spool/anacron/目录中存在cron.{daily,weekly,monthly}文件，这些文件中都保存着anacron上次执行时的时间。anacron会去读取这些文件中的时间，然后和当前时间做比较，若果两个时间的差值超过了anacron的指定时间差值（一般是1天，7天和一个月），就说明有定时任务漏掉了没有被执行，这时anacron会介入而执行这个漏掉的定时任务，从而保证在关机时没有被执行的定时任务不会被漏掉。</p>
<p>在CentOS 6.x中，我们使用cronie-anacron取代了vixie-cron软件包。而且在原先的CentOS版本中/etc/cron.{daily,weekly,monthly}这些目录中的定时任务会同时被cron和anacron调用，这样非常容易出现重复执行同一个定时任务的错误。在现在的CentOS  6.x中，/etc/cron.{daily,weekly,monthly}目录中的定时任务程序只会被anacron调用，从而保证这些定时任务只会在每天、每周或每月被定时执行一次，而不会重复执行。这也是我们在上一个小节中介绍的CentOS 6.x的变化之一。</p>
<p>在CentOS 6.x中anacron还有一个变化，anacron不再是单独的服务，而变成了系统命令。也就是说我们不再可以使用“service anacron restart”命令来管理anacron服务了。而是需要使用anacron命令来管理anacron工作，具体命令如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# anacron [选项] [工作名] </span><br><span class="line">选项：    </span><br><span class="line">	-s：开始anacron工作，依据&#x2F;etc&#x2F;anacrontab文件中的设定的延迟时间执行    </span><br><span class="line">	-n：立即执行&#x2F;etc&#x2F;anacrontab中所有的工作，忽略所有的延迟时间    </span><br><span class="line">	-u：更新&#x2F;var&#x2F;spool&#x2F;anacron&#x2F;cron.&#123;daily,weekly,monthly&#125;文件中的时间戳，但不执行任何工作</span><br><span class="line">参数：</span><br><span class="line">	工作名：是依据&#x2F;etc&#x2F;anacrontab文件中定义的工作名</span><br></pre></td></tr></table></figure>

<p>在我们当前的Li nux中，其实不需要执行任何anacron命令，只需要配置好/etc/anacrontab文件，系统就会依赖这个文件中的设定来通过anacron执行定时任务。那么关键就是/etc/anacrontab文件的内容了，这个文件如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vi &#x2F;etc&#x2F;anacrontab</span><br><span class="line"># &#x2F;etc&#x2F;anacrontab: configuration file for anacron</span><br><span class="line"></span><br><span class="line"># See anacron(8) and anacrontab(5) for details. </span><br><span class="line"></span><br><span class="line">SHELL&#x3D;&#x2F;bin&#x2F;sh</span><br><span class="line">PATH&#x3D;&#x2F;sbin:&#x2F;bin:&#x2F;usr&#x2F;sbin:&#x2F;usr&#x2F;bin</span><br><span class="line">MAILTO&#x3D;root</span><br><span class="line">#前面的内容和&#x2F;etc&#x2F;crontab类似</span><br><span class="line"></span><br><span class="line"># the maximal random delay added to the base delay of the jobs</span><br><span class="line">RANDOM_DELAY&#x3D;45 </span><br><span class="line">#最大随机延迟。</span><br><span class="line"># the jobs will be started during the following hours only</span><br><span class="line">START_HOURS_RANGE&#x3D;3-22</span><br><span class="line">#anacron的执行时间范围是3:00-22:00 </span><br><span class="line"></span><br><span class="line">#period in days   delay in minutes   job-identifier   command</span><br><span class="line">1       	5       cron.daily              nice run-parts &#x2F;etc&#x2F;cron.daily </span><br><span class="line">7       	25      cron.weekly             nice run-parts &#x2F;etc&#x2F;cron.weekly </span><br><span class="line">@monthly 	45     	cron.monthly            nice run-parts &#x2F;etc&#x2F;cron.monthly</span><br><span class="line">#天数		强制延迟（分）工作名称					实际执行的命令</span><br><span class="line">#时间差超过天数时，强制延迟多少分钟之后，就执行命令</span><br></pre></td></tr></table></figure>

<p>这个文件中“RANDOM_DELAY”定义的是最大随机延迟，也就是说cron.daily任务如果超过1天没有执行，并不会马上执行，而是先延迟强制延迟时间之后，再延迟随机延迟时间之后再执行命令。“START_HOURS_RANGE”定义anacron的执行时间范围，anacron只会在这个时间范围之内执行。</p>
<p>我们用cron.daily工作来说明下/etc/anacrontab的执行过程：</p>
<ul>
<li>首先读取/var/spool/anacron/cron.daily中的上一次anacron执行的时间；</li>
<li>和当前时间比较，如果两个时间的差值超过1天，就执行cron.daily工作；</li>
<li>执行这个工作只能在03:00-22:00之间；</li>
<li>执行工作时强制延迟时间为5分钟，再随机延迟0-45分钟时间；</li>
<li>使用nice命令指定默认优先级，使用run-   parts脚本执行/etc/cron.daily目录中的所有可执行文件。</li>
</ul>
<p>大家发现了吧，/etc/cron.{daily,weekly,monthly}中的脚本，在当前的Linux中是被anacron调用的，不再依靠cron服务。不过anacron不用设置多余的配置，我们只需要把需要定时执行的脚本放入/etc/cron.{daily,weekly,monthly}目录当中，就会每天、每周或每月执行，而且也不再需要启动anacron服务了。我们如果做修改的话，只用修改/etc/anacrontab配置文件即可。比如我更加习惯让定时任务在凌晨03:00-05:00执行，就可以如下修改：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vi &#x2F;etc&#x2F;anacrontab</span><br><span class="line"># &#x2F;etc&#x2F;anacrontab: configuration file for anacron</span><br><span class="line"></span><br><span class="line"># See anacron(8) and anacrontab(5) for details. </span><br><span class="line"></span><br><span class="line">SHELL&#x3D;&#x2F;bin&#x2F;sh</span><br><span class="line">PATH&#x3D;&#x2F;sbin:&#x2F;bin:&#x2F;usr&#x2F;sbin:&#x2F;usr&#x2F;bin</span><br><span class="line">MAILTO&#x3D;root</span><br><span class="line"># the maximal random delay added to the base delay of the jobs</span><br><span class="line">RANDOM_DELAY&#x3D;0</span><br><span class="line">#随机延迟改为0分钟，不再随机延迟</span><br><span class="line"># the jobs will be started during the following hours onlySTART_HOURS_RANGE&#x3D;3-5</span><br><span class="line">#执行时间范围为03:00-05:00 </span><br><span class="line"></span><br><span class="line">#period in days   delay in minutes   job-identifier   command</span><br><span class="line">1       0       cron.daily              nice run-parts &#x2F;etc&#x2F;cron.daily </span><br><span class="line">7       0      cron.weekly             nice run-parts &#x2F;etc&#x2F;cron.weekly </span><br><span class="line">@monthly 0     cron.monthly            nice run-parts &#x2F;etc&#x2F;cron.monthly </span><br><span class="line">#强制延迟也改为0分钟，不再强制延迟</span><br></pre></td></tr></table></figure>

<p>这样我们所有放入/etc/cron.{daily,weekly,monthly}目录中的脚本都会在指定时间运行了，而且也不怕服务器万一关机的情况了。</p>

            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="false">
                <source type="audio/mpeg" src="">
            </audio>
            
                <ul id="audio-list" style="display:none">
                    
                </ul>
            
        </div>
        
    <div id='gitalk-container' class="comment link"
		data-enable='false'
        data-ae='false'
        data-ci=''
        data-cs=''
        data-r=''
        data-o=''
        data-a=''
        data-d='false'
    >查看评论</div>


    </div>
    
</div>


    </div>
</div>
</body>


<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/typed.js"></script>
<script src="/js/diaspora.js"></script>


<link rel="stylesheet" href="/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css">


<script src="/photoswipe/photoswipe.min.js"></script>
<script src="/photoswipe/photoswipe-ui-default.min.js"></script>


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>






</html>
