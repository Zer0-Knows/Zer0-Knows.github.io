<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Welcome to new World</title>
    <url>/9999/10/10/My-New-Post/</url>
    <content><![CDATA[<p>世界が平和でありますように</p>
]]></content>
  </entry>
  <entry>
    <title>Markdown基本语法</title>
    <url>/2020/05/11/page-2/</url>
    <content><![CDATA[<h1 id="一、标题"><a href="#一、标题" class="headerlink" title="一、标题"></a>一、标题</h1><p>在想要设置为标题的文字前面加#来表示<br> 一个#是一级标题，二个#是二级标题，以此类推。支持六级标题。</p>
<p>注：标准语法一般在#后跟个空格再写文字。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 这是一级标题</span><br><span class="line">## 这是二级标题</span><br><span class="line">### 这是三级标题</span><br><span class="line">#### 这是四级标题</span><br><span class="line">##### 这是五级标题</span><br><span class="line">###### 这是六级标题</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<h1 id="这是一级标题"><a href="#这是一级标题" class="headerlink" title="这是一级标题"></a>这是一级标题</h1><h2 id="这是二级标题"><a href="#这是二级标题" class="headerlink" title="这是二级标题"></a>这是二级标题</h2><h3 id="这是三级标题"><a href="#这是三级标题" class="headerlink" title="这是三级标题"></a>这是三级标题</h3><h4 id="这是四级标题"><a href="#这是四级标题" class="headerlink" title="这是四级标题"></a>这是四级标题</h4><h5 id="这是五级标题"><a href="#这是五级标题" class="headerlink" title="这是五级标题"></a>这是五级标题</h5><h6 id="这是六级标题"><a href="#这是六级标题" class="headerlink" title="这是六级标题"></a>这是六级标题</h6><hr>
<h1 id="二、字体"><a href="#二、字体" class="headerlink" title="二、字体"></a>二、字体</h1><ul>
<li><h5 id="加粗"><a href="#加粗" class="headerlink" title="加粗"></a>加粗</h5></li>
</ul>
<p>要加粗的文字左右分别用两个*号包起来</p>
<ul>
<li><h5 id="斜体"><a href="#斜体" class="headerlink" title="斜体"></a>斜体</h5></li>
</ul>
<p>要倾斜的文字左右分别用一个*号包起来</p>
<ul>
<li><h5 id="斜体加粗"><a href="#斜体加粗" class="headerlink" title="斜体加粗"></a>斜体加粗</h5></li>
</ul>
<p>要倾斜和加粗的文字左右分别用三个*号包起来</p>
<ul>
<li><h5 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h5></li>
</ul>
<p>要加删除线的文字左右分别用两个~~号包起来</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">**这是加粗的文字**</span><br><span class="line">*这是倾斜的文字*&#96;</span><br><span class="line">***这是斜体加粗的文字***</span><br><span class="line">~~这是加删除线的文字~~</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<p><strong>这是加粗的文字</strong><br> <em>这是倾斜的文字</em><br> <strong><em>这是斜体加粗的文字\</em></strong><br> <del>这是加删除线的文字</del></p>
<hr>
<h1 id="三、引用"><a href="#三、引用" class="headerlink" title="三、引用"></a>三、引用</h1><p>在引用的文字前加&gt;即可。引用也可以嵌套，如加两个&gt;&gt;三个&gt;&gt;&gt;<br> n个…<br> 貌似可以一直加下去，但没神马卵用</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;这是引用的内容</span><br><span class="line">&gt;&gt;这是引用的内容</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;这是引用的内容</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<blockquote>
<p>这是引用的内容</p>
<blockquote>
<p>这是引用的内容</p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>这是引用的内容</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<h1 id="四、分割线"><a href="#四、分割线" class="headerlink" title="四、分割线"></a>四、分割线</h1><p>三个或者三个以上的 - 或者 * 都可以。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">----</span><br><span class="line">***</span><br><span class="line">*****</span><br></pre></td></tr></table></figure>

<p>效果如下：<br> 可以看到，显示效果是一样的。</p>
<hr>
<hr>
<hr>
<hr>
<h1 id="五、图片"><a href="#五、图片" class="headerlink" title="五、图片"></a>五、图片</h1><p>语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">![图片alt](图片地址 &#39;&#39;图片title&#39;&#39;)</span><br><span class="line"></span><br><span class="line">图片alt就是显示在图片下面的文字，相当于对图片内容的解释。</span><br><span class="line">图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">![moon](https:&#x2F;&#x2F;pbs.twimg.com&#x2F;media&#x2F;EXq9Y9BUwAECKgv?format&#x3D;png&amp;name&#x3D;small &quot;123&quot;)</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<p><img src="https://pbs.twimg.com/media/EXq9Y9BUwAECKgv?format=png&name=small" alt="moon" title="123"></p>
<h1 id="六、超链接"><a href="#六、超链接" class="headerlink" title="六、超链接"></a>六、超链接</h1><p>语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[超链接名](超链接地址 &quot;超链接title&quot;)</span><br><span class="line">title可加可不加</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[简书](http:&#x2F;&#x2F;jianshu.com)</span><br><span class="line">[百度](http:&#x2F;&#x2F;baidu.com)</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<p><a href="https://www.jianshu.com/u/1f5ac0cf6a8b" target="_blank" rel="noopener">简书</a><br> <a href="https://links.jianshu.com/go?to=http%3A%2F%2Fbaidu.com" target="_blank" rel="noopener">百度</a></p>
<p>注：Markdown本身语法不支持链接在新页面中打开，如果想要在新页面中打开的话可以用html语言的a标签代替。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;a href&#x3D;&quot;超链接地址&quot; target&#x3D;&quot;_blank&quot;&gt;超链接名&lt;&#x2F;a&gt;</span><br><span class="line"></span><br><span class="line">示例</span><br><span class="line">&lt;a href&#x3D;&quot;https:&#x2F;&#x2F;www.jianshu.com&#x2F;u&#x2F;1f5ac0cf6a8b&quot; target&#x3D;&quot;_blank&quot;&gt;简书&lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="七、列表"><a href="#七、列表" class="headerlink" title="七、列表"></a>七、列表</h1><h5 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h5><p>语法：<br> 无序列表用 - + * 任何一种都可以</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- 列表内容</span><br><span class="line">+ 列表内容</span><br><span class="line">* 列表内容</span><br><span class="line"></span><br><span class="line">注意：- + * 跟内容之间都要有一个空格</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<ul>
<li>列表内容</li>
<li>列表内容</li>
<li>列表内容</li>
</ul>
<h5 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h5><p>语法：<br> 数字加点</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 列表内容</span><br><span class="line">2. 列表内容</span><br><span class="line">3. 列表内容</span><br><span class="line"></span><br><span class="line">注意：序号跟内容之间要有空格</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<ol>
<li>列表内容</li>
<li>列表内容</li>
<li>列表内容</li>
</ol>
<h5 id="列表嵌套"><a href="#列表嵌套" class="headerlink" title="列表嵌套"></a>列表嵌套</h5><p><strong>上一级和下一级之间敲三个空格即可</strong></p>
<ul>
<li>一级无序列表内容<ul>
<li>二级无序列表内容</li>
<li>二级无序列表内容</li>
<li>二级无序列表内容</li>
</ul>
</li>
<li>一级无序列表内容<ol>
<li>二级有序列表内容</li>
<li>二级有序列表内容</li>
<li>二级有序列表内容</li>
</ol>
</li>
</ul>
<ol>
<li>一级有序列表内容<ul>
<li>二级无序列表内容</li>
<li>二级无序列表内容</li>
<li>二级无序列表内容</li>
</ul>
</li>
<li>一级有序列表内容<ol>
<li>二级有序列表内容</li>
<li>二级有序列表内容</li>
<li>二级有序列表内容</li>
</ol>
</li>
</ol>
<hr>
<h1 id="八、表格"><a href="#八、表格" class="headerlink" title="八、表格"></a>八、表格</h1><p>语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">表头|表头|表头</span><br><span class="line">---|:--:|---:</span><br><span class="line">内容|内容|内容</span><br><span class="line">内容|内容|内容</span><br><span class="line"></span><br><span class="line">第二行分割表头和内容。</span><br><span class="line">- 有一个就行，为了对齐，多加了几个</span><br><span class="line">文字默认居左</span><br><span class="line">-两边加：表示文字居中</span><br><span class="line">-右边加：表示文字居右</span><br><span class="line">注：原生的语法两边都要用 | 包起来。此处省略</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">姓名|技能|排行</span><br><span class="line">--|:--:|--:</span><br><span class="line">刘备|哭|大哥</span><br><span class="line">关羽|打|二哥</span><br><span class="line">张飞|骂|三弟</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<table>
<thead>
<tr>
<th>姓名</th>
<th align="center">技能</th>
<th align="right">排行</th>
</tr>
</thead>
<tbody><tr>
<td>刘备</td>
<td align="center">哭</td>
<td align="right">大哥</td>
</tr>
<tr>
<td>关羽</td>
<td align="center">打</td>
<td align="right">二哥</td>
</tr>
<tr>
<td>张飞</td>
<td align="center">骂</td>
<td align="right">三弟</td>
</tr>
</tbody></table>
<h1 id="九、代码"><a href="#九、代码" class="headerlink" title="九、代码"></a>九、代码</h1><p>语法：<br> 单行代码：代码之间分别用一个反引号包起来</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;代码内容&#96;</span><br></pre></td></tr></table></figure>

<p>代码块：代码之间分别用三个反引号包起来，且两边的反引号单独占一行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(&#96;&#96;&#96;)</span><br><span class="line">  代码...</span><br><span class="line">  代码...</span><br><span class="line">  代码...</span><br><span class="line">(&#96;&#96;&#96;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：为了防止转译，前后三个反引号处加了小括号，实际是没有的。这里只是用来演示，实际中去掉两边小括号即可。</p>
</blockquote>
<p>示例：</p>
<p>单行代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;create database hero;&#96;</span><br></pre></td></tr></table></figure>

<p>代码块</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(&#96;&#96;&#96;)</span><br><span class="line">    function fun()&#123;</span><br><span class="line">         echo &quot;这是一句非常牛逼的代码&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    fun();</span><br><span class="line">(&#96;&#96;&#96;)</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<p>单行代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create database hero;</span><br></pre></td></tr></table></figure>

<p>代码块</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function fun()&#123;</span><br><span class="line">  echo &quot;这是一句非常牛逼的代码&quot;;</span><br><span class="line">&#125;</span><br><span class="line">fun();</span><br></pre></td></tr></table></figure>

<h1 id="十、流程图"><a href="#十、流程图" class="headerlink" title="十、流程图"></a>十、流程图</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(&#96;&#96;&#96;)flow</span><br><span class="line">st&#x3D;&gt;start: 开始</span><br><span class="line">op&#x3D;&gt;operation: My Operation</span><br><span class="line">cond&#x3D;&gt;condition: Yes or No?</span><br><span class="line">e&#x3D;&gt;end</span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;e</span><br><span class="line">cond(no)-&gt;op</span><br><span class="line">&amp;(&#96;&#96;&#96;)</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">st&#x3D;&gt;start: 开始</span><br><span class="line">op&#x3D;&gt;operation: My Operation</span><br><span class="line">cond&#x3D;&gt;condition: Yes or No?</span><br><span class="line">e&#x3D;&gt;end</span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;e</span><br><span class="line">cond(no)-&gt;op</span><br><span class="line">&amp;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>C51单片机指令表</title>
    <url>/2020/05/20/page-3/</url>
    <content><![CDATA[<p>指令                               字节                周期                       动作说明<br> 算数运算指令<br> 1．ADD A,Rn                 1                      1                       将累加器与寄存器的内容相加，结果存回累加器<br> 2．ADD A,direct           2                       1                       将累加器与直接地址的内容相加，结果存回累加器<br> 3．ADD A,@Ri              1                       1                       将累加器与间接地址的内容相加，结果存回累加器<br> 4．ADD A,#data          2                       1                        将累加器与常数相加，结果存回累加器<br> 5．ADDC A,Rn             1                       1                        将累加器与寄存器的内容及进位C相加，结果存回累加器<br> 6．ADDC A,direct        2                       1                        将累加器与直接地址的内容及进位C相加，结果存回累加器<br> 7．ADDC A,@Ri           1                        1                        将累加器与间接地址的内容及进位C相加，结果存回累加器<br> 8．ADDC A,#data        2                        1                        将累加器与常数及进位C相加，结果存回累加器<br> 9．SUBB A,Rn              1                        1                        将累加器的值减去寄存器的值减借位C，结果存回累加器<br> 10．SUBB A,direct       2                        1                        将累加器的值减直接地址的值减借位C，结果存回累加器<br> 11．SUBB A,@Ri          1                        1                        将累加器的值减间接地址的值减借位C，结果存回累加器<br> 12．SUBB A,#data      2                        1                        将累加器的值减常数值减借位C，结果存回累加器<br> 13．INC A                     1                        1                        将累加器的值加1<br> 14．INC Rn                   1                        1                        将寄存器的值加l<br> 15．INC direct             2                        1                        将直接地址的内容加1<br> 16．INC @Ri                1                        1                        将间接地址的内容加1<br> 17．INC DPTR              1                        1                        数据指针寄存器值加1<br> 说明：将16位的DPTR加1，当DPTR的低字节(DPL)从FFH溢出至00H时，会使高字节(DPH)加1，不影响任何标志位<br> 18．DEC A                   1                        1                        将累加器的值减1<br> 19．DEC Rn                 1                        1                        将寄存器的值减1<br> 20．DEC direct           2                        1                        将直接地址的内容减1<br> 21．DEC @Ri              1                        1                        将间接地址的内容减1<br> 22．MUL AB               1                        4                        将累加器的值与B寄存器的值相乘，乘积的低位字节存回累加器，高位字节 存回B寄存器<br> 说明：将累加器A和寄存器B内的无符号整数相乘，产生16位的积，低位字节存入A，高位字节存入B寄存器。如果积大于FFH，则溢出标志位(OV)被设定为1，而进位标志位为0<br> 23．DIV AB                   1                        4                        将累加器的值除以B寄存器的值，结果的商存回累加器，余数存回B寄存器<br> 说明：无符号的除法运算，将累加器A除以B寄存器的值，商存入A，余数存入B。执行本指令后，进位位(C)及溢出位(OV)被清除为0<br> 24．DA A                        1                        1                        将累加器A作十进制调整，<br> 若(A) 3-0&gt;9或(AC)=1，则(A) 3-0←(A)3-0+6<br> 若(A) 7-4&gt;9或 (C)=1，则(A) 7-4←(A)7-4+6<br> 逻辑运算指令<br> 25．ANL A,Rn              1                        1                        将累加器的值与寄存器的值做AND的逻辑判断，结果存回累加器<br> 26．ANL A,direct        2                        1                        将累加器的值与直接地址的内容做AND的逻辑判断，结果存回累加器<br> 27．ANL A,@Ri             1                        1                        将累加器的值与间接地址的内容做AND的逻辑判断，结果存回累加器<br> 28．ANL A,#data         2                        1                        将累加器的值与常数做AND的逻辑判断，结果存回累加器<br> 29．ANL direct,A        2                        1                        将直接地址的内容与累加器的值做AND的逻辑判断，结果存回该直接地址<br> 30．ANL direct,#data  3                        2                        将直接地址的内容与常数值做AND的逻辑判断，结果存回该直接地址<br> 31．ORL A,Rn              1                        1                        将累加器的值与寄存器的值做OR的逻辑判断，结果存回累加器<br> 32．ORL A,direct        2                        1                        将累加器的值与直接地址的内容做OR的逻辑判断，结果存回累加器<br> 33．ORL A,@Ri             1                        1                        将累加器的值与间接地址的内容做OR的逻辑判断，结果存回累加器<br> 34．ORL A,#data        2                        1                        将累加器的值与常数做OR的逻辑判断，结果存回累加器<br> 35．ORL direct,A        2                        1                        将直接地址的内容与累加器的值做OR的逻辑判断，结果存回该直接地址<br> 36．ORL direct,#data  3                        2                        将直接地址的内容与常数值做OR的逻辑判断，结果存回该直接地址<br> 37．XRL A,Rn              1                        1                        将累加器的值与寄存器的值做XOR的逻辑判断，结果存回累加器<br> 38．XRL A,direct        2                        1                        将累加器的值与直接地址的内容做XOR的逻辑判断，结果存回累加器<br> 39．XRL A,@Ri             1                        1                        将累加器的值与间接地扯的内容做XOR的逻辑判断，结果存回累加器<br> 40．XRL A,#data        2                        1                        将累加器的值与常数作XOR的逻辑判断，结果存回累加器<br> 41．XRL direct,A        2                        1                        将直接地址的内容与累加器的值做XOR的逻辑判断，结果存回该直接地址<br> 42．XRL direct,#data  3                        2                        将直接地址的内容与常数的值做XOR的逻辑判断，结果存回该直接地址<br> 43．CLR A                   1                        1                        清除累加器的值为0<br> 44．CPL A                   1                        1                        将累加器的值反相<br> 45．RL A                    1                        1                        将累加器的值左移一位<br> 46．RLC A                   1                        1                        将累加器含进位C左移一位<br> 47．RR A                    1                        1                        将累加器的值右移一位<br> 48．RRC A                   1                        1                        将累加器含进位C右移一位<br> 49．SWAP A               1                        1                        将累加器的高4位与低4位的内容交换。(A)3-0←(A)7-4<br> 数据转移指令<br> 50．MOV A,Rn              1                        1                        将寄存器的内容载入累加器<br> 51．MOV A,direct        2                        1                        将直接地址的内容载入累加器<br> 52．MOV A,@Ri             1                        1                        将间接地址的内容载入累加器<br> 53．MOV A,#data        2                        1                        将常数载入累加器<br> 54．MOV Rn，A           1                         1                         将累加器的内容载入寄存器<br> 55．MOV Rn,direct       2                         2                         将直接地址的内容载入寄存器<br> 56．MOV Rn,gdata        2                         1                         将常数载入寄存器<br> 57．MOV direct,A            2                         1                         将累加器的内容存入直接地址<br> 58．MOV direct,Rn       2                         2                         将寄存器的内容存入直接地址<br> 59．MOV direct1, direct2     3                         2                         将直接地址2的内容存入直接地址1<br> 60．MOV direct,@Ri           2                         2                         将间接地址的内容存入直接地址<br> 61．MOV direct,#data      3                         2                         将常数存入直接地址<br> 62．MOV @Ri,A             1                         1                         将累加器的内容存入某间接地址<br> 63．MOV @Ri,direct       2                         2                         将直接地址的内容存入某间接地址<br> 64．MOV @Ri,#data       2                         1                         将常数存入某间接地址<br> 65．MOV DPTR,#data16  3                         2                         将16位的常数存入数据指针寄存器<br> 66．MOVC A,@A+DPTR   1                         2                         (A) ←((A)+(DPTR))<br> 累加器的值再加数据指针寄存器的值为其所指定地址，将该地址的内容读入累加器<br> 67．MOVC A,@A+PC        1                         2                         (PC)←(PC)+1；(A)←((A)+(PC))累加器的值加程序计数器的值作为其所指定地址，将该地址的内容读入累加器<br> 68．MOVX A,@Ri             1                         2                         将间接地址所指定外部存储器的内容读入累加器(8位地址)<br> 69．MOVX A,@DPTR        1                         2                         将数据指针所指定外部存储器的内容读入累加器(16位地址)<br> 70．MOVX @Ri,A             1                         2                         将累加器的内容写入间接地址所指定的外部存储器(8位地址)<br> 71．MOVX @DPTR,A        1                         2                         将累加器的内容写入数据指针所指定的外部存储器(16位地址)<br> 72．PUSH direct                2                         2                         将直接地址的内容压入堆栈区<br> 73．POP direct                 2                         2                         从堆栈弹出该直接地址的内容<br> 74．XCH A,Rn                   1                         1                         将累加器的内容与寄存器的内容互换<br> 75．XCH A,direct             2                         1                         将累加器的值与直接地址的内容互换<br> 76．XCH A,@Ri                1                         1                         将累加器的值与间接地址的内容互换<br> 77．XCHD A,@Ri             1                         1                         将累加器的低4位与间接地址的低4位互换<br> 布尔代数运算<br> 78．CLR C                        1                         1                         清除进位C为0<br> 79．CLR bit                      2                         1                         清除直接地址的某位为0<br> 80．SETB C                       1                         1                         设定进位C为1<br> 81．SETB bit                    2                         1                         设定直接地址的某位为1<br> 82．CPL C                        1                         1                         将进位C的值反相<br> 83．CPL bit                      2                         1                         将直接地址的某位值反相<br> 84．ANL C,bit                 2                         2                         将进位C与直接地址的某位做AND的逻辑判断，结果存回进位C<br> 85．ANL C,/bit                 2                         2                         将进位C与直接地址的某位的反相值做AND的逻辑判断，结果存回进位C<br> 86．ORL C,bit                 2                           2                         将进位C与直接地址的某位做OR的逻辑判断，结果存回进位C<br> 87．ORL C,/bit                 2                        2                         将进位C与直接地址的某位的反相值做OR的逻辑判断，结果存回进位C<br> 88．MOV C,bit                 2                         1                         将直接地址的某位值存入进位C<br> 89．MOV bit,C                 2                         2                         将进位C的值存入直接地址的某位<br> 90．JC rel                           2                         2                         若进位C=1则跳至rel的相关地址<br> 91．JNC rel                      2                         2                         若进位C=0则跳至rel的相关地址<br> 92．JB bit,rel                     3                         2                         若直接地址的某位为1，则跳至rel的相关地址<br> 93．JNB bit,rel                3                         2                         若直接地址的某位为0，则跳至rel的相关地址<br> 94．JBC bit,rel                3                         2                         若直接地址的某位为1，则跳至rel的相关地址，并将该位值清除为0<br> 程序跳跃<br> 95．ACALL addr11         2                        2                        调用2K程序存储器范围内的子程序<br> 96．LCALL addr16         3                        2                        调用64K程序存储器范围内的子程序<br> 97．RET                            1                        2                        从子程序返回<br> 98．RETI                           1                        2                        从中断子程序返回<br> 99．AJMP addr11           2                         2                         绝对跳跃(2K内)<br> 100．LJMP addr16          3                         2                         长跳跃(64K内)<br> 101．SJMP rel                   2                         2                         短跳跃(2K内)-128～+127字节<br> 102．JMP @A+DPTR        1                         2                         跳至累加器的内容加数据指针所指的相关地址<br> 103．JZ rel                          2                         2                         累加器的内容为0，则跳至rel所指相关地址<br> 104．JNZ rel                       2                         2                         累加器的内容不为0，则跳至rel所指相关地址<br> 105．CJNE A,direct,rel      3                         2                         将累加器的内容与直接地址的内容比较，不相等则跳至rel所指的相关地址<br> 106．CJNE A,#data,rel       3                         2                         将累加器的内容与常数比较，若不相等则跳至rel所指的相关地址<br> 107．CJNE @Rn,#data,rel     3                         2                         将寄存器的内容与常数比较，若不相等则跳至rel所指的相关地址<br> 108．CJNE @Ri,#data,rel     3                         2                         将间接地址的内容与常数比较，若不相等则跳至rel所指的相关地址<br> 109．DJNZ Rn,rel                2                         2                         将寄存器的内容减1，不等于0则跳至rel所指的相关地址<br> 110．DJNZ direct,rel          3                          2                         将直接地址的内容减1，不等于0则跳至rel所指的相关地址<br> 111．NOP                         1                             1                         无动作</p>
]]></content>
  </entry>
  <entry>
    <title>Shell基本语法</title>
    <url>/2020/09/11/page-4/</url>
    <content><![CDATA[<p>指向解释器 #!/bin/bash (可用其他解释器，不写时默认调用bash)</p>
<p>打印 echo”输出内容”</p>
<p>定义变量 例 i=0</p>
<p>调用变量 例 echo $i</p>
<p>运算     例 echo $[$a+$b] (推荐)</p>
<p>​          echo $(($a+$b))</p>
<p>​           expr $a + $b</p>
<p>条件    例 [ $a = $b ] （条件非空为true，空为false，例 [ asd ] 为true）</p>
<p>常用判断条件</p>
<p>（1）整数间比较</p>
<p>= 字符串比较</p>
<p>-lt 小于（less than）</p>
<p>-le 小于等于 （less equal）</p>
<p>-eq 等于 （equal）</p>
<p>-gt 大于（greater than） </p>
<p>-ge 大于等于 （greater equal）</p>
<p>-ne 不等于 （not equal）</p>
<p>（2）文件权限判断</p>
<p>  -r 有读权限 （read）</p>
<p>  -w 有写权限 （write）</p>
<p>  -x 有执行权限 （execute）</p>
<p>（3）文件类型判断</p>
<p>-f 文件存在且为常规文件（file）</p>
<p>-e 文件存在（existence）</p>
<p>-d 文件存在且为目录（directory）</p>
<p>预定义变量：</p>
<p>$HOME 家目录</p>
<p>$PWD 当前目录</p>
<p>$USER 当前用户</p>
<p>$SHELL 当前解释器</p>
<p>系统变量</p>
<p>$n  （n为1-9,10以上用${n}）</p>
<p>$#    变量个数</p>
<p>例 $1 = args[0]</p>
<p>  $# = args.length</p>
<p>$*     所有参数（看作整体）</p>
<p>$@   所有参数（单独区分）</p>
<p>$?    状态码（0为正常运行）</p>
<p>readonly 设置变量只读，不可改变</p>
<p>unset 撤销变量（不可撤销readonly变量）</p>
<p>if判断</p>
<p>基本语法：</p>
<p>if[ 判断判断式 ],then</p>
<p> 程序</p>
<p>fi</p>
<p>或</p>
<p>if[ 判断判断式 ]</p>
<p> then</p>
<p>  程序</p>
<p>elif[ 判断判断式 ]</p>
<p> then</p>
<p>  程序</p>
<p>else</p>
<p> 程序</p>
<p>fi</p>
<p>case语句</p>
<p>基本语法：</p>
<p>case $变量名 in</p>
<p>  “值1”)</p>
<p>  如果变量值等于值1，执行程序1</p>
<p>  ;;</p>
<p>  “值2”)</p>
<p>  如果变量值等于值2，执行程序2</p>
<p>  ;;</p>
<p>……省略</p>
<p>  *)</p>
<p>  如果变量值不为以上值，执行此程序</p>
<p>  ;;</p>
<p>esac</p>
<p>for循环</p>
<p>基本语法：</p>
<p>for((初始值;循环控制条件;变量变化 ))</p>
<p>  do</p>
<p>​     程序</p>
<p>  done</p>
<p>基本语法2</p>
<p>for 变量 in 值1 值2 值3…</p>
<p>  do</p>
<p>​     程序</p>
<p>  done</p>
<p>while循环</p>
<p>基本语法：</p>
<p>while[ 条件判断式 ]</p>
<p>  do</p>
<p>​     程序</p>
<p>  done</p>
<p>read读取控制台输入</p>
<p>基本语法</p>
<p>read(选项)(参数)</p>
<p>选项：</p>
<p>  -p 指定读取值时的提示符</p>
<p>  -t 指定读取值时的等待时间</p>
<p>函数</p>
<p>基本语法：</p>
<p>function functionname() (可省略function或括号的其中一个，不可同时省略)</p>
<p>{</p>
<p>  函数内容;</p>
<p>}</p>
<p>函数的参数调用</p>
<p>例：</p>
<p>function plus()</p>
<p>{</p>
<p>  echo$[$1+$2]</p>
<p>}</p>
<p>plus 1 2</p>
<p><strong>Shell工具：</strong></p>
<p>1.cut</p>
<p>cut命令从文件的每一行剪切字节、字符、字段并输出</p>
<p>基本用法：</p>
<p>cut[选项参数] filename</p>
<p>参数：</p>
<p>-f 列号，提取第几列</p>
<p>-d 分隔符，按照指定分隔符分割列</p>
<p>-c 指定具体的字符（第几个字符）</p>
<p>2.sed</p>
<p>流处理编辑器，逐行处理输出，本身不会改变文件内容，除非使用重定向存储输出</p>
<p>基本用法：</p>
<p>sed[参数选项] ‘command’ filename</p>
<p>参数：</p>
<p>-e 直接在指令列模式上进行sed的动作编辑</p>
<p>-i 直接编辑文件</p>
<p>命令：（命令前接行号，可通过逗号划分多行，也可使用正则表达式）</p>
<p>a 新增，在a后面可接字串没在下一行出现</p>
<p>d 删除</p>
<p>s 查找并替换（使用正则表达式划分 例sed ‘3s/原内容/替换内容/g’ g表示全局替换）</p>
<p>正则规则：</p>
<p>\ 转义</p>
<p>^ 一行的开头</p>
<p>  ^R表示以R开头的行</p>
<p>$ 一行的结束</p>
<p>  R$表示以R结尾的行</p>
<p>* 表示上一个子式匹配0次或多次，贪心匹配</p>
<p>  Zo* </p>
<p>​       Z</p>
<p>​       Zo</p>
<p>​       Zooo</p>
<p>. 匹配一个任意字符</p>
<p>  .*匹配任意字符串</p>
<p>[] 表示匹配某个范围内的字符</p>
<p>  [a-z] 匹配一个a-z之间的字符</p>
<p>   [a-z]* 匹配任意字母字符串</p>
<p>（使用正则表达式需要用斜杠括起来）</p>
<p>3.awk</p>
<p>文本分析工具，把文本逐行读入，以空格为默认分隔符将每行切片，切开的部分再进行分析处理</p>
<p>基本用法</p>
<p>awk[选项参数] ‘pattem1{action1} pattem2{action2}…’ filename</p>
<p>pattem:表示AWK在数据中查找的内容（匹配模式）</p>
<p>action：在找到匹配内容时所执行的一系列命令</p>
<p>参数：</p>
<p>-F 指定输入文件拆分隔符</p>
<p>-v 赋值一个用户定义变量</p>
<p>BEGIN 数据到来之前先执行</p>
<p>END 数据处理完毕后执行</p>
<p>例：’BEGIN{print “BEGIN”}END{print”END”}’</p>
<p>内置变量：</p>
<p>FILENAME 文件名</p>
<p>NR 已读记录数</p>
<p>NF 浏览记录的域的个数（切割后，列的个数）</p>
<p>4.sort</p>
<p>将文件进行排序，并将结果标准输出</p>
<p>基本语法：</p>
<p>sort(选项)(参数)</p>
<p>参数</p>
<p>-n 依照数值大小排序</p>
<p>-r 以相反顺序排序</p>
<p>-t 设置排序时所用分隔字符</p>
<p>-k 设定需要排序的列</p>
]]></content>
  </entry>
  <entry>
    <title>社会工程学攻击解析</title>
    <url>/2020/05/10/page-1/</url>
    <content><![CDATA[<p>社会工程学攻击是一种通过对被攻击者心理弱点、本能反应、好奇心、信任、贪婪等心理陷阱所采取的诸如欺骗、伤害等危害手段，获取自身利益的手法。当黑客攻击与社会工程学攻击融为一体时，将根本不存在所谓安全的系统，所谓“No patch for stupid”</p>
<p>1.对特定的环境实施渗透，是社工为了获取所需敏感信息的常用手段之一。黑客通过观察被攻击者对电子邮件的响应速度、重视程度以及与被攻击者相关的资料，如个人姓名、生日、电话号码、电子邮箱地址等，通过对搜集的信息进行综合利用，进而判断被攻击的账号密码等大致内容</p>
<p>2.伪装欺骗也是社工的主要手段之一。电子邮件伪造、网络钓鱼等攻击手法均可实现伪造欺骗被攻击者，可实现诱惑被攻击者进入指定页面下载并运行恶意程序，或是要求被攻击者输入敏感账号密码等信息进行“验证”等，黑客利用被攻击者疏于防范的心理引诱用户进而实现伪装欺骗的目的</p>
<p>3.说服是对互联网信息安全危害较大的一种社工方法。它要求被攻击者与攻击者达成某种一致，进而为黑客攻击过程提供各种便利条件，当被攻击者的利益与黑客的利益没有冲突时，甚至与黑客的利益一致时，该种手段就会非常有效</p>
<p>4.黑客在实施社工的过程中，常会利用被攻击者对安全、漏洞、病毒等内容的敏感性，以权威机构的身份出现，散布安全警告、系统风险等消息，用危言耸听的伎俩恐吓、欺骗被攻击者，并声称不按照他们的方式去处理就会造成非常严重的危害和损失，借此实现对被攻击者敏感信息的获取</p>
<p>5.社工手段高明的黑客需要精通心理学、人际关系学、行为学等知识和技能，善于利用人们的本能反应、好奇心、盲目信任、贪婪等弱点设置陷阱，实施欺骗，并控制他人为己服务。他们通常十分友善，讲究说话的艺术，知道如何借助机会去恭维他人，投其所好，使多数人友善地做出回应</p>
]]></content>
  </entry>
  <entry>
    <title>XSS与CSRF的区别</title>
    <url>/2020/09/21/page-5/</url>
    <content><![CDATA[<p>1.CSRF的基本概念、缩写、全称</p>
<p>CSRF（Cross-site request forgery）：跨站请求伪造。PS：中文名一定要记住。英文全称，如果记不住也拉倒。</p>
<p>2.CSRF的攻击原理</p>
<p>用户是网站A的注册用户，且登录进去，于是网站A就给用户下发cookie。从上图可以看出，要完成一次CSRF攻击，受害者必须满足两个必要的条件：</p>
<p>（1）登录受信任网站A，并在本地生成Cookie。（如果用户没有登录网站A，那么网站B在诱导的时候，请求网站A的api接口时，会提示你登录）</p>
<p>（2）在不登出A的情况下，访问危险网站B（其实是利用了网站A的漏洞）。我们在讲CSRF时，一定要把上面的两点说清楚。温馨提示一下，cookie保证了用户可以处于登录状态，但网站B其实拿不到 cookie。</p>
<p>3、CSRF如何防御</p>
<p>方法一、Token 验证：（用的最多）</p>
<p>（1）服务器发送给客户端一个token；</p>
<p>（2）客户端提交的表单中带着这个token。</p>
<p>（3）如果这个 token 不合法，那么服务器拒绝这个请求。</p>
<p>方法二：隐藏令牌：把 token 隐藏在 http 的 head头中。方法二和方法一有点像，本质上没有太大区别，只是使用方式上有区别。方法三、Referer 验证：Referer 指的是页面请求来源。意思是，只接受本站的请求，服务器才做响应；如果不是，就拦截。</p>
<p>XSS</p>
<p>1、XSS的基本概念</p>
<p>XSS（Cross Site Scripting）：跨域脚本攻击。XSS的攻击原理XSS攻击的核心原理是：不需要你做任何的登录认证，它会通过合法的操作（比如在url中输入、在评论框中输入），向你的页面注入脚本（可能是js、hmtl代码块等）。最后导致的结果可能是：盗用Cookie破坏页面的正常结构，插入广告等恶意内容D-doss攻击XSS的攻击方式1、反射型发出请求时，XSS代码出现在url中，作为输入提交到服务器端，服务器端解析后响应，XSS代码随响应内容一起传回给浏览器，最后浏览器解析执行XSS代码。这个过程像一次反射，所以叫反射型XSS。</p>
<p>2、存储型存储型XSS和反射型XSS的差别在于，提交的代码会存储在服务器端（数据库、内存、文件系统等），下次请求时目标页面时不用再提交XSS代码。</p>
<p>XSS的防范措施（encode + 过滤）</p>
<p>XSS的防范措施主要有三个：</p>
<p>1、编码：对用户输入的数据进行HTML Entity 编码。如上图所示，把字符转换成 转义字符。Encode的作用是将$var等一些字符进行转化，使得浏览器在最终输出结果上是一样的。比如说这段代码：<script>alert(1)</script>若不进行任何处理，则浏览器会执行alert的js操作，实现XSS注入。进行编码处理之后，L在浏览器中的显示结果就是<script>alert(1)</script>，实现了将$var作为纯文本进行输出，且不引起JavaScript的执行。</p>
<p>2、过滤：移除用户输入的和事件相关的属性。如onerror可以自动触发攻击，还有onclick等。（总而言是，过滤掉一些不安全的内容）移除用户输入的Style节点、Script节点、Iframe节点。（尤其是Script节点，它可是支持跨域的呀，一定要移除）。</p>
<p>3、校正避免直接对HTML Entity进行解码。使用DOM Parse转换，校正不配对的DOM标签。备注：我们应该去了解一下DOM Parse这个概念，它的作用是把文本解析成DOM结构。比较常用的做法是，通过第一步的编码转成文本，然后第三步转成DOM对象，然后经过第二步的过滤。还有一种简洁的答案：首先是encode，如果是富文本，就白名单。</p>
<p>CSRF 和 XSS 的区别</p>
<p>区别一：CSRF：需要用户先登录网站A，获取 cookie。XSS：不需要登录。</p>
<p>区别二：（原理的区别）CSRF：是利用网站A本身的漏洞，去请求网站A的api。XSS：是向网站 A 注入 JS代码，然后执行 JS 里的代码，篡改网站A的内容。</p>
]]></content>
  </entry>
  <entry>
    <title>运维学习建议</title>
    <url>/2020/10/04/linux1/</url>
    <content><![CDATA[<h2 id="一、学习Linux的注意事项"><a href="#一、学习Linux的注意事项" class="headerlink" title="一、学习Linux的注意事项"></a>一、学习Linux的注意事项</h2><h3 id="1-Linux严格区分大小写"><a href="#1-Linux严格区分大小写" class="headerlink" title="1.Linux严格区分大小写"></a>1.Linux严格区分大小写</h3><p>Linux是严格区分大小写的，这一点和Windows不一样，所以操作时要注意区分大小写的不同，包括文件名和目录名、命令、命令选项、配置文件设置选项等。</p>
<h3 id="2-Linux一切皆文件"><a href="#2-Linux一切皆文件" class="headerlink" title="2. Linux一切皆文件"></a>2. Linux一切皆文件</h3><p>Linux中所有内容都是以文件的形式保存和管理的，硬件设备也是文件，这和Windows完全不同，Windows是通过设备管理器来管理硬件的。Linux的设备文件保存在/dev/目录中，硬盘文件是/dev/sd[a-p]，光盘文件是/dev/hdc等。</p>
<h3 id="3-Linux不靠扩展名区分文件类型"><a href="#3-Linux不靠扩展名区分文件类型" class="headerlink" title="3.Linux不靠扩展名区分文件类型"></a>3.Linux不靠扩展名区分文件类型</h3><p>Windows是依赖扩展名区分文件类型的，比如，“.txt”是文本文件、“.exe”是执行文件、“.ini”是配置文件、“.mp4”是小电影等。但Linux不是靠扩展名区分文件类型的，而是靠权限位标识来确定文件类型的，而且文件类型的种类也不像Windows下那么多，常见的文件类型只有普通文件、目录、链接文件、块设备文件、字符设备文件等几种。Linux的可执行文件不过就是普通文件被赋予了可执行权限而已。</p>
<p>但Linux中的一些特殊文件还是要求写“扩展名”的，但是大家小心，并不是Linux一定要靠扩展名来识别文件类型，写这些扩展名是为了帮助管理员来区分不同的文件类型。这样的文件扩展名主要有以下几种。</p>
<ul>
<li><p>压缩包：Linux下常见的压缩文件名有<em>.gz、</em>.bz2、<em>.zip、</em> . t a r. g z、<em>.tar.bz2、</em>.tgz等。为什么压缩包一定要写扩展名呢？其实很好理解，如果不写清楚扩展名，那么管理员不容易判断压缩包的格式，虽然有命令可以帮助判断，但是直观一点更加方便。另外，就算没写扩展名，在Linux中一样可以解压缩，不影响使用。</p>
</li>
<li><p>二进制软件包：CentOS中所使用的二进制安装包是RPM包，所有的RPM包都用“.rpm”扩展名结尾，目的同样是让管理员一目了然。</p>
</li>
<li><p>程序文件：Shell脚本一般用“<em>.sh”扩展名结尾，其他还有用“</em>.c”扩展名结尾的C语言文件等。</p>
</li>
<li><p>网页文件：网页文件一般使用“<em>.html”“</em>.php”等结尾，不过这是网页服务器的要求，而不是Linux的要求。</p>
</li>
</ul>
<h3 id="4．Linux中所有的存储设备都必须在挂载之后才能使用"><a href="#4．Linux中所有的存储设备都必须在挂载之后才能使用" class="headerlink" title="4．Linux中所有的存储设备都必须在挂载之后才能使用"></a>4．Linux中所有的存储设备都必须在挂载之后才能使用</h3><p>Linux中所有的存储设备都有自己的设备文件名，这些设备文件必须在挂载之后才能使用，包括硬盘、U盘和光盘。挂载其实就是给这些存储设备分配盘符，只不过Windows中的盘符用英文字母表示 ，而Linux中的盘符则是一个已经建立的空目录。我们把这些空目录叫作挂载点（可以理解为Windows的盘符），把设备文件（如/dev/sdb）和挂载点（已经建立的空目录）连接的过程叫作挂载</p>
<h3 id="5．Windows下的程序不能直接在Linux中使用"><a href="#5．Windows下的程序不能直接在Linux中使用" class="headerlink" title="5．Windows下的程序不能直接在Linux中使用"></a>5．Windows下的程序不能直接在Linux中使用</h3><p>Linux和Windows是不同的操作系统，可以安装和使用的软件也是不同的，所以能够在Windows中安装的软件是不能在Linux中安装的。有好处吗？当然有，那就是能够感染Windows的病毒和木马都对Linux无效。有坏处吗？也有，那就是所有的软件要想在Linux中安装，必须单独开发针对Linux的版本，或者依赖模拟器软件运行。很多软件也会同时推出针对Windows和Linux的版本，如大家熟悉的即时通信软件QQ。</p>
<h2 id="二、服务器管理建议"><a href="#二、服务器管理建议" class="headerlink" title="二、服务器管理建议"></a>二、服务器管理建议</h2><h3 id="1．了解Linux目录结构"><a href="#1．了解Linux目录结构" class="headerlink" title="1．了解Linux目录结构"></a>1．了解Linux目录结构</h3><table>
<thead>
<tr>
<th>目录名</th>
<th>目录的作用</th>
</tr>
</thead>
<tbody><tr>
<td>/bin/</td>
<td>存放系统命令的目录，普通用户和超级用户都可以执行。是/usr/bin/目录的软链接</td>
</tr>
<tr>
<td>/sbin/</td>
<td>存放系统  命令的目录，只有超级用户才可以执行。是/usr/sbin/目录的软链接</td>
</tr>
<tr>
<td>/usr/bin/</td>
<td>存放系统命令的目录，普通用户和超级用户都可以执行</td>
</tr>
<tr>
<td>/usr/sbin/</td>
<td>存放系统  命令的目录，只有超级用户才可以执</td>
</tr>
<tr>
<td>/boot/</td>
<td>系统启动目录，保存与系统启动相关的文件，如内核文件和启动引导程序（grub）文件等</td>
</tr>
<tr>
<td>/dev/</td>
<td>设备文件保存位置</td>
</tr>
<tr>
<td>/etc/</td>
<td>配置文件保存位置。系统内所有采用默认安装方式（rpm安装）的服务配置文件全部保存在此目录中，如用户信息、服务的启动脚本、常用服务的配置文件等</td>
</tr>
<tr>
<td>/home/</td>
<td>普通用户的家目录。在创建用户时，每个用户要有一个默认登录和保存自己数据的位置，就是用户的家目录，所有普通用户的宿主目录是在/home/下建立一个和用户名相同的目录。如用户user1的家目录就是/home/user1/</td>
</tr>
<tr>
<td>/lib/</td>
<td>系统调用的函数库保存位置。是/usr/lib/的软链接</td>
</tr>
<tr>
<td>/lib64/</td>
<td>64位函数库保存位置。是/usr/lib64/的软链接</td>
</tr>
<tr>
<td>/lost+found/</td>
<td>当系统意外崩溃或机器意外关机，而产生一些文件碎片放在这里。当系统启动的过程中fsck工具会检查这里，并修复已经损坏的文件系统。这个目录只在每个分区中出现，例如/lost+found就是根分区的备份恢复目录，/boot/lost+found就是/boot分区的备份恢复目录</td>
</tr>
<tr>
<td>/media/</td>
<td>挂载目录。系统建议是用来挂载媒体设备的，如软盘和光盘</td>
</tr>
<tr>
<td>/misc/</td>
<td>挂载目录。系统建议用来挂载NFS服务的共享目录。我们在刚刚已经解释了挂载，童鞋们应该知道只要是一个已经建立的空目录就可以作为挂载点。那么系统虽然准备了三个默认挂载目录/media、/mnt、/misc，但是到底在哪个目录中挂载什么设备都可以由管理员自己决定。例如超哥接触Linux的时候，默认挂载目录只有/mnt一个，所以养成了在/mnt下建立不同目录挂载不同设备的习惯。如/mnt/cdrom挂载光盘，/mnt/usb挂载U盘，这都是可以的</td>
</tr>
<tr>
<td>/mnt/</td>
<td>挂载目录。早期Linux中只有这一个挂载目录，并没有细分。现在系统建议这个目录用来挂载额外的设备，如U盘、移动硬盘和其他操作系统的分区</td>
</tr>
<tr>
<td>/opt/</td>
<td>第三方安装的软件保存位置。这个目录是放置和安装其他软件的位置，手工安装的源码包软件都可以安装到这个目录中。不过超哥还是习惯把软件放到/usr/local/目录中，也就是说，/usr/local/目录也可以用来安装软件</td>
</tr>
<tr>
<td>/proc/</td>
<td>虚拟文件系统。该目录中的数据并不保存在硬盘上，而是保存到内存中。主要保存系统的内核、进程、外部设备状态和网络状态等。如/proc/cpuinfo是保存CPU信息的，/proc/devices是保存设备驱动的列表的，/proc/filesystems是保存文件系统列表的，/proc/net是保存网络协议信息的…..</td>
</tr>
<tr>
<td>/sys/</td>
<td>虚拟文件系统。和/proc/目录相似，该目录中的数据都保存在内存中，主要保存与内核相关的信息</td>
</tr>
<tr>
<td>/root/</td>
<td>root的宿主目录。普通用户宿主目录在/home/下，root宿主目录直接在“/”下</td>
</tr>
<tr>
<td>/run/</td>
<td>系统运行时产生的数据，如ssid，pid等相关数据。/var/run/是此目录的软链接</td>
</tr>
<tr>
<td>/srv/</td>
<td>服务数据目录。一些系统服务启动之后，可以在这个目录中保存所需要的数据</td>
</tr>
<tr>
<td>/tmp/</td>
<td>临时目录。系统存放临时文件的目录，在该目录下，所有用户都可以访问和写入。我们建议此目录中不能保存重要数据，最好每次开机都把该目录清空</td>
</tr>
<tr>
<td>/usr/</td>
<td>系统软件资源目录。注意usr不是user的缩写，而是“UNIX Software Resource”的缩写，所以不是存放用户数据的目录，而是存放系统软件资源的目录。系统中安装的软件大多数保存在这里</td>
</tr>
<tr>
<td>/usr/lib/</td>
<td>应用程序调用的函数库保存位置</td>
</tr>
<tr>
<td>/usr/local/</td>
<td>手工安装的软件保存位置。我们一般建议源码包软件安装在这个位置</td>
</tr>
<tr>
<td>/usr/share/</td>
<td>应用程序的资源文件保存位置，如帮助文档、说明文档和字体目录</td>
</tr>
<tr>
<td>/usr/src/</td>
<td>源码包保存位置。我们手工下载的源码包和内核源码包都可以保存到这里。不过超哥更习惯把手工下载的源码包保存到/usr/local/src/目录中，把内核源码保存到/usr/src/kernels/目录中</td>
</tr>
<tr>
<td>/usr/src/kernels/</td>
<td>内核源码保存位置</td>
</tr>
<tr>
<td>/var/</td>
<td>动态数据保存位置。主要保存缓存、日志以及软件运行所产生的文件</td>
</tr>
<tr>
<td>/var/www/html/</td>
<td>RPM包安装的Apache的网页主目录</td>
</tr>
<tr>
<td>/var/lib/</td>
<td>程序运行中需要调用或改变的数据保存位置。如MySQL的数据库保存在/var/lib/mysql/目录中</td>
</tr>
<tr>
<td>/var/log/</td>
<td>系统日志保存位置</td>
</tr>
<tr>
<td>/var/run/</td>
<td>一些服务和程序运行后，它们的PID（进程ID）保存位置。是/run/目录的软链接</td>
</tr>
<tr>
<td>/var/spool/</td>
<td>放置队列数据的目录。就是排队等待其他程序使用的数据，比如邮件队列和打印队列</td>
</tr>
<tr>
<td>/var/spool/mail/</td>
<td>新收到的邮件队列保存位置。系统新收到的邮件会保存在此目录中</td>
</tr>
<tr>
<td>/var/spool/cron/</td>
<td>系统的定时任务队列保存位置。系统的计划任务会保存在这里</td>
</tr>
</tbody></table>
<h3 id="2-远程服务器关机及重启时的注意事项"><a href="#2-远程服务器关机及重启时的注意事项" class="headerlink" title="2.远程服务器关机及重启时的注意事项"></a>2.远程服务器关机及重启时的注意事项</h3><p>为什么远程服务器不能关机呢？很简单，远程服务器没有放置在本地，关机后，谁可以帮你按开机电源键启动服务器？虽然计算机技术日新月异，但是像插入电源和开机这样的工作还是需要手工进行的。如果服务器在远程，一旦关机，就只能求助托管机房的管理人员帮你开机了。远程服务器重启时需要注意两点。</p>
<h5 id="2-1远程服务器在重启前，要中止正在执行的服务"><a href="#2-1远程服务器在重启前，要中止正在执行的服务" class="headerlink" title="2.1远程服务器在重启前，要中止正在执行的服务"></a>2.1远程服务器在重启前，要中止正在执行的服务</h5><p>计算机的硬盘最怕在高速存储时断电或重启，非常容易造成硬盘损坏。所以，在重启前先中止你的服务，甚至可以考虑暂时断开对外提供服务的网络。可能你会觉得服务器有这么娇贵吗？我的笔记本电脑经常强行关机，也没有发现硬盘损坏啊？这是因为你的个人计算机没有很多人访问，强制断电时硬盘并没有进行数据交换。小心驶得万年船！</p>
<h5 id="2-2重启命令的选用"><a href="#2-2重启命令的选用" class="headerlink" title="2.2重启命令的选用"></a>2.2重启命令的选用</h5><p>Linux可以识别的重启命令有很多条，但是建议大家使用“shutdown -r now”命令重启。这条命令在重启时会正常保存和中止服务器中正在运行的程序，是安全重启命令。而且最好在重启前执行几次“sync”命令，这条命令是数据同步命令，可以让暂时保存在内存中的数据同步到硬盘上。</p>
<h3 id="3．不要在服务器访问高峰运行高负载命令"><a href="#3．不要在服务器访问高峰运行高负载命令" class="headerlink" title="3．不要在服务器访问高峰运行高负载命令"></a>3．不要在服务器访问高峰运行高负载命令</h3><p>这一点大家很好理解，在服务器访问高峰，如果使用一些对服务器压力较大的命令，则有可能会造成服务器响应缓慢甚至死机。哪些命令是高负载命令呢？其实，如果大家使用过Windows操作系统，则也会留意到一些操作会给计算机带来较大的运算压力，道理都是一样的，如复制大量的数据、压缩或者解压缩大文件、大范围的硬盘搜索等。什么时间算作访问高峰期呢？我们一般认为17:00—24:00算作访问高峰期。当然，每台服务器具体提供的服务不同，访问高峰期有时也会有所出入。比如，服务器主要是供美国人民访问的，那就要考虑时差的问题；或者服务器提供的服务很特殊，访问高峰期可能也不同。一般我们建议在凌晨4:00—5:00执行这些命令。那是不是说我们需要在凌晨上班？当然不是，这谁受得了啊？我们可以使用系统的计划任务，让操作自动在指定的时间段执行。</p>
<h3 id="4．远程配置防火墙时不要把自己踢出服务器"><a href="#4．远程配置防火墙时不要把自己踢出服务器" class="headerlink" title="4．远程配置防火墙时不要把自己踢出服务器"></a>4．远程配置防火墙时不要把自己踢出服务器</h3><p>简单来讲，防火墙就是根据数据包自身的参数来判断是否允许数据包通过的网络设备。我们的服务器要想在公网中安全地使用，就需要使用防火墙过滤有害的数据包。但是在配置防火墙时，如果管理员对防火墙不是很熟悉，则有可能把自己的正常访问数据包和有害数据包全部过滤掉，导致自己也无法正常登录服务器，如防火墙关闭了远程连接的SSH服务的端口。防火墙配置完全是靠手工命令完成的，配置规则和配置命令相对也比较复杂，万一设置的时候心不在焉，悲剧就发生了。如何避免这种尴尬的情况发生呢？最好的方法当然是在服务器本地配置防火墙，这样就算不小心把自己的远程登录给过滤了，还可以通过本机登录来进行恢复。如果服务器已经在远程登录了，要配置防火墙，那么最好在本地测试完善后再进行上传，这样会把发生故障的概率降到最低。虽然在本地测试好了，但是传到远程服务器上时仍有可能发生问题。于是超哥想到一个笨办法：如果需要远程配置防火墙，那么先写一个系统定时任务，让它每5分钟清空一下防火墙规则，就算写错了也还有反悔的机会，等测试没有问题了再删除这个系统定时任务</p>
<h3 id="5．指定合理的密码规范并定期更新"><a href="#5．指定合理的密码规范并定期更新" class="headerlink" title="5．指定合理的密码规范并定期更新"></a>5．指定合理的密码规范并定期更新</h3><p>前面我们介绍了设置密码需要遵守复杂性、易记忆性和时效性的三原则，这里就不再重复解释了。</p>
<h3 id="6．合理分配权限"><a href="#6．合理分配权限" class="headerlink" title="6．合理分配权限"></a>6．合理分配权限</h3><p>服务器管理有一个最简单的原则：给予用户最小的权限。</p>
<h3 id="7．定期备份重要数据和日志"><a href="#7．定期备份重要数据和日志" class="headerlink" title="7．定期备份重要数据和日志"></a>7．定期备份重要数据和日志</h3><p>备份的基本原则：不要把鸡蛋放在同一个篮子里</p>
]]></content>
      <tags>
        <tag>linux运维基础</tag>
      </tags>
  </entry>
</search>
