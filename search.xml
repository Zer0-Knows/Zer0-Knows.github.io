<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Welcome to new World</title>
    <url>/9999/10/10/My-New-Post/</url>
    <content><![CDATA[<p>世界が平和でありますように</p>
]]></content>
  </entry>
  <entry>
    <title>Markdown基本语法</title>
    <url>/2020/05/11/page-2/</url>
    <content><![CDATA[<h1 id="一、标题"><a href="#一、标题" class="headerlink" title="一、标题"></a>一、标题</h1><p>在想要设置为标题的文字前面加#来表示<br> 一个#是一级标题，二个#是二级标题，以此类推。支持六级标题。</p>
<p>注：标准语法一般在#后跟个空格再写文字。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 这是一级标题</span><br><span class="line">## 这是二级标题</span><br><span class="line">### 这是三级标题</span><br><span class="line">#### 这是四级标题</span><br><span class="line">##### 这是五级标题</span><br><span class="line">###### 这是六级标题</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<h1 id="这是一级标题"><a href="#这是一级标题" class="headerlink" title="这是一级标题"></a>这是一级标题</h1><h2 id="这是二级标题"><a href="#这是二级标题" class="headerlink" title="这是二级标题"></a>这是二级标题</h2><h3 id="这是三级标题"><a href="#这是三级标题" class="headerlink" title="这是三级标题"></a>这是三级标题</h3><h4 id="这是四级标题"><a href="#这是四级标题" class="headerlink" title="这是四级标题"></a>这是四级标题</h4><h5 id="这是五级标题"><a href="#这是五级标题" class="headerlink" title="这是五级标题"></a>这是五级标题</h5><h6 id="这是六级标题"><a href="#这是六级标题" class="headerlink" title="这是六级标题"></a>这是六级标题</h6><hr>
<h1 id="二、字体"><a href="#二、字体" class="headerlink" title="二、字体"></a>二、字体</h1><ul>
<li><h5 id="加粗"><a href="#加粗" class="headerlink" title="加粗"></a>加粗</h5></li>
</ul>
<p>要加粗的文字左右分别用两个*号包起来</p>
<ul>
<li><h5 id="斜体"><a href="#斜体" class="headerlink" title="斜体"></a>斜体</h5></li>
</ul>
<p>要倾斜的文字左右分别用一个*号包起来</p>
<ul>
<li><h5 id="斜体加粗"><a href="#斜体加粗" class="headerlink" title="斜体加粗"></a>斜体加粗</h5></li>
</ul>
<p>要倾斜和加粗的文字左右分别用三个*号包起来</p>
<ul>
<li><h5 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h5></li>
</ul>
<p>要加删除线的文字左右分别用两个~~号包起来</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">**这是加粗的文字**</span><br><span class="line">*这是倾斜的文字*&#96;</span><br><span class="line">***这是斜体加粗的文字***</span><br><span class="line">~~这是加删除线的文字~~</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<p><strong>这是加粗的文字</strong><br> <em>这是倾斜的文字</em><br> <strong><em>这是斜体加粗的文字\</em></strong><br> <del>这是加删除线的文字</del></p>
<hr>
<h1 id="三、引用"><a href="#三、引用" class="headerlink" title="三、引用"></a>三、引用</h1><p>在引用的文字前加&gt;即可。引用也可以嵌套，如加两个&gt;&gt;三个&gt;&gt;&gt;<br> n个…<br> 貌似可以一直加下去，但没神马卵用</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;这是引用的内容</span><br><span class="line">&gt;&gt;这是引用的内容</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;这是引用的内容</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<blockquote>
<p>这是引用的内容</p>
<blockquote>
<p>这是引用的内容</p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>这是引用的内容</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<h1 id="四、分割线"><a href="#四、分割线" class="headerlink" title="四、分割线"></a>四、分割线</h1><p>三个或者三个以上的 - 或者 * 都可以。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">----</span><br><span class="line">***</span><br><span class="line">*****</span><br></pre></td></tr></table></figure>

<p>效果如下：<br> 可以看到，显示效果是一样的。</p>
<hr>
<hr>
<hr>
<hr>
<h1 id="五、图片"><a href="#五、图片" class="headerlink" title="五、图片"></a>五、图片</h1><p>语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">![图片alt](图片地址 &#39;&#39;图片title&#39;&#39;)</span><br><span class="line"></span><br><span class="line">图片alt就是显示在图片下面的文字，相当于对图片内容的解释。</span><br><span class="line">图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">![moon](https:&#x2F;&#x2F;pbs.twimg.com&#x2F;media&#x2F;EXq9Y9BUwAECKgv?format&#x3D;png&amp;name&#x3D;small &quot;123&quot;)</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<p><img src="https://pbs.twimg.com/media/EXq9Y9BUwAECKgv?format=png&name=small" alt="moon" title="123"></p>
<h1 id="六、超链接"><a href="#六、超链接" class="headerlink" title="六、超链接"></a>六、超链接</h1><p>语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[超链接名](超链接地址 &quot;超链接title&quot;)</span><br><span class="line">title可加可不加</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[简书](http:&#x2F;&#x2F;jianshu.com)</span><br><span class="line">[百度](http:&#x2F;&#x2F;baidu.com)</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<p><a href="https://www.jianshu.com/u/1f5ac0cf6a8b" target="_blank" rel="noopener">简书</a><br> <a href="https://links.jianshu.com/go?to=http%3A%2F%2Fbaidu.com" target="_blank" rel="noopener">百度</a></p>
<p>注：Markdown本身语法不支持链接在新页面中打开，如果想要在新页面中打开的话可以用html语言的a标签代替。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;a href&#x3D;&quot;超链接地址&quot; target&#x3D;&quot;_blank&quot;&gt;超链接名&lt;&#x2F;a&gt;</span><br><span class="line"></span><br><span class="line">示例</span><br><span class="line">&lt;a href&#x3D;&quot;https:&#x2F;&#x2F;www.jianshu.com&#x2F;u&#x2F;1f5ac0cf6a8b&quot; target&#x3D;&quot;_blank&quot;&gt;简书&lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="七、列表"><a href="#七、列表" class="headerlink" title="七、列表"></a>七、列表</h1><h5 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h5><p>语法：<br> 无序列表用 - + * 任何一种都可以</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- 列表内容</span><br><span class="line">+ 列表内容</span><br><span class="line">* 列表内容</span><br><span class="line"></span><br><span class="line">注意：- + * 跟内容之间都要有一个空格</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<ul>
<li>列表内容</li>
<li>列表内容</li>
<li>列表内容</li>
</ul>
<h5 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h5><p>语法：<br> 数字加点</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 列表内容</span><br><span class="line">2. 列表内容</span><br><span class="line">3. 列表内容</span><br><span class="line"></span><br><span class="line">注意：序号跟内容之间要有空格</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<ol>
<li>列表内容</li>
<li>列表内容</li>
<li>列表内容</li>
</ol>
<h5 id="列表嵌套"><a href="#列表嵌套" class="headerlink" title="列表嵌套"></a>列表嵌套</h5><p><strong>上一级和下一级之间敲三个空格即可</strong></p>
<ul>
<li>一级无序列表内容<ul>
<li>二级无序列表内容</li>
<li>二级无序列表内容</li>
<li>二级无序列表内容</li>
</ul>
</li>
<li>一级无序列表内容<ol>
<li>二级有序列表内容</li>
<li>二级有序列表内容</li>
<li>二级有序列表内容</li>
</ol>
</li>
</ul>
<ol>
<li>一级有序列表内容<ul>
<li>二级无序列表内容</li>
<li>二级无序列表内容</li>
<li>二级无序列表内容</li>
</ul>
</li>
<li>一级有序列表内容<ol>
<li>二级有序列表内容</li>
<li>二级有序列表内容</li>
<li>二级有序列表内容</li>
</ol>
</li>
</ol>
<hr>
<h1 id="八、表格"><a href="#八、表格" class="headerlink" title="八、表格"></a>八、表格</h1><p>语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">表头|表头|表头</span><br><span class="line">---|:--:|---:</span><br><span class="line">内容|内容|内容</span><br><span class="line">内容|内容|内容</span><br><span class="line"></span><br><span class="line">第二行分割表头和内容。</span><br><span class="line">- 有一个就行，为了对齐，多加了几个</span><br><span class="line">文字默认居左</span><br><span class="line">-两边加：表示文字居中</span><br><span class="line">-右边加：表示文字居右</span><br><span class="line">注：原生的语法两边都要用 | 包起来。此处省略</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">姓名|技能|排行</span><br><span class="line">--|:--:|--:</span><br><span class="line">刘备|哭|大哥</span><br><span class="line">关羽|打|二哥</span><br><span class="line">张飞|骂|三弟</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<table>
<thead>
<tr>
<th>姓名</th>
<th align="center">技能</th>
<th align="right">排行</th>
</tr>
</thead>
<tbody><tr>
<td>刘备</td>
<td align="center">哭</td>
<td align="right">大哥</td>
</tr>
<tr>
<td>关羽</td>
<td align="center">打</td>
<td align="right">二哥</td>
</tr>
<tr>
<td>张飞</td>
<td align="center">骂</td>
<td align="right">三弟</td>
</tr>
</tbody></table>
<h1 id="九、代码"><a href="#九、代码" class="headerlink" title="九、代码"></a>九、代码</h1><p>语法：<br> 单行代码：代码之间分别用一个反引号包起来</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;代码内容&#96;</span><br></pre></td></tr></table></figure>

<p>代码块：代码之间分别用三个反引号包起来，且两边的反引号单独占一行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(&#96;&#96;&#96;)</span><br><span class="line">  代码...</span><br><span class="line">  代码...</span><br><span class="line">  代码...</span><br><span class="line">(&#96;&#96;&#96;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：为了防止转译，前后三个反引号处加了小括号，实际是没有的。这里只是用来演示，实际中去掉两边小括号即可。</p>
</blockquote>
<p>示例：</p>
<p>单行代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;create database hero;&#96;</span><br></pre></td></tr></table></figure>

<p>代码块</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(&#96;&#96;&#96;)</span><br><span class="line">    function fun()&#123;</span><br><span class="line">         echo &quot;这是一句非常牛逼的代码&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    fun();</span><br><span class="line">(&#96;&#96;&#96;)</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<p>单行代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create database hero;</span><br></pre></td></tr></table></figure>

<p>代码块</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function fun()&#123;</span><br><span class="line">  echo &quot;这是一句非常牛逼的代码&quot;;</span><br><span class="line">&#125;</span><br><span class="line">fun();</span><br></pre></td></tr></table></figure>

<h1 id="十、流程图"><a href="#十、流程图" class="headerlink" title="十、流程图"></a>十、流程图</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(&#96;&#96;&#96;)flow</span><br><span class="line">st&#x3D;&gt;start: 开始</span><br><span class="line">op&#x3D;&gt;operation: My Operation</span><br><span class="line">cond&#x3D;&gt;condition: Yes or No?</span><br><span class="line">e&#x3D;&gt;end</span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;e</span><br><span class="line">cond(no)-&gt;op</span><br><span class="line">&amp;(&#96;&#96;&#96;)</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">st&#x3D;&gt;start: 开始</span><br><span class="line">op&#x3D;&gt;operation: My Operation</span><br><span class="line">cond&#x3D;&gt;condition: Yes or No?</span><br><span class="line">e&#x3D;&gt;end</span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;e</span><br><span class="line">cond(no)-&gt;op</span><br><span class="line">&amp;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>C51单片机指令表</title>
    <url>/2020/05/20/page-3/</url>
    <content><![CDATA[<p>指令                               字节                周期                       动作说明<br> 算数运算指令<br> 1．ADD A,Rn                 1                      1                       将累加器与寄存器的内容相加，结果存回累加器<br> 2．ADD A,direct           2                       1                       将累加器与直接地址的内容相加，结果存回累加器<br> 3．ADD A,@Ri              1                       1                       将累加器与间接地址的内容相加，结果存回累加器<br> 4．ADD A,#data          2                       1                        将累加器与常数相加，结果存回累加器<br> 5．ADDC A,Rn             1                       1                        将累加器与寄存器的内容及进位C相加，结果存回累加器<br> 6．ADDC A,direct        2                       1                        将累加器与直接地址的内容及进位C相加，结果存回累加器<br> 7．ADDC A,@Ri           1                        1                        将累加器与间接地址的内容及进位C相加，结果存回累加器<br> 8．ADDC A,#data        2                        1                        将累加器与常数及进位C相加，结果存回累加器<br> 9．SUBB A,Rn              1                        1                        将累加器的值减去寄存器的值减借位C，结果存回累加器<br> 10．SUBB A,direct       2                        1                        将累加器的值减直接地址的值减借位C，结果存回累加器<br> 11．SUBB A,@Ri          1                        1                        将累加器的值减间接地址的值减借位C，结果存回累加器<br> 12．SUBB A,#data      2                        1                        将累加器的值减常数值减借位C，结果存回累加器<br> 13．INC A                     1                        1                        将累加器的值加1<br> 14．INC Rn                   1                        1                        将寄存器的值加l<br> 15．INC direct             2                        1                        将直接地址的内容加1<br> 16．INC @Ri                1                        1                        将间接地址的内容加1<br> 17．INC DPTR              1                        1                        数据指针寄存器值加1<br> 说明：将16位的DPTR加1，当DPTR的低字节(DPL)从FFH溢出至00H时，会使高字节(DPH)加1，不影响任何标志位<br> 18．DEC A                   1                        1                        将累加器的值减1<br> 19．DEC Rn                 1                        1                        将寄存器的值减1<br> 20．DEC direct           2                        1                        将直接地址的内容减1<br> 21．DEC @Ri              1                        1                        将间接地址的内容减1<br> 22．MUL AB               1                        4                        将累加器的值与B寄存器的值相乘，乘积的低位字节存回累加器，高位字节 存回B寄存器<br> 说明：将累加器A和寄存器B内的无符号整数相乘，产生16位的积，低位字节存入A，高位字节存入B寄存器。如果积大于FFH，则溢出标志位(OV)被设定为1，而进位标志位为0<br> 23．DIV AB                   1                        4                        将累加器的值除以B寄存器的值，结果的商存回累加器，余数存回B寄存器<br> 说明：无符号的除法运算，将累加器A除以B寄存器的值，商存入A，余数存入B。执行本指令后，进位位(C)及溢出位(OV)被清除为0<br> 24．DA A                        1                        1                        将累加器A作十进制调整，<br> 若(A) 3-0&gt;9或(AC)=1，则(A) 3-0←(A)3-0+6<br> 若(A) 7-4&gt;9或 (C)=1，则(A) 7-4←(A)7-4+6<br> 逻辑运算指令<br> 25．ANL A,Rn              1                        1                        将累加器的值与寄存器的值做AND的逻辑判断，结果存回累加器<br> 26．ANL A,direct        2                        1                        将累加器的值与直接地址的内容做AND的逻辑判断，结果存回累加器<br> 27．ANL A,@Ri             1                        1                        将累加器的值与间接地址的内容做AND的逻辑判断，结果存回累加器<br> 28．ANL A,#data         2                        1                        将累加器的值与常数做AND的逻辑判断，结果存回累加器<br> 29．ANL direct,A        2                        1                        将直接地址的内容与累加器的值做AND的逻辑判断，结果存回该直接地址<br> 30．ANL direct,#data  3                        2                        将直接地址的内容与常数值做AND的逻辑判断，结果存回该直接地址<br> 31．ORL A,Rn              1                        1                        将累加器的值与寄存器的值做OR的逻辑判断，结果存回累加器<br> 32．ORL A,direct        2                        1                        将累加器的值与直接地址的内容做OR的逻辑判断，结果存回累加器<br> 33．ORL A,@Ri             1                        1                        将累加器的值与间接地址的内容做OR的逻辑判断，结果存回累加器<br> 34．ORL A,#data        2                        1                        将累加器的值与常数做OR的逻辑判断，结果存回累加器<br> 35．ORL direct,A        2                        1                        将直接地址的内容与累加器的值做OR的逻辑判断，结果存回该直接地址<br> 36．ORL direct,#data  3                        2                        将直接地址的内容与常数值做OR的逻辑判断，结果存回该直接地址<br> 37．XRL A,Rn              1                        1                        将累加器的值与寄存器的值做XOR的逻辑判断，结果存回累加器<br> 38．XRL A,direct        2                        1                        将累加器的值与直接地址的内容做XOR的逻辑判断，结果存回累加器<br> 39．XRL A,@Ri             1                        1                        将累加器的值与间接地扯的内容做XOR的逻辑判断，结果存回累加器<br> 40．XRL A,#data        2                        1                        将累加器的值与常数作XOR的逻辑判断，结果存回累加器<br> 41．XRL direct,A        2                        1                        将直接地址的内容与累加器的值做XOR的逻辑判断，结果存回该直接地址<br> 42．XRL direct,#data  3                        2                        将直接地址的内容与常数的值做XOR的逻辑判断，结果存回该直接地址<br> 43．CLR A                   1                        1                        清除累加器的值为0<br> 44．CPL A                   1                        1                        将累加器的值反相<br> 45．RL A                    1                        1                        将累加器的值左移一位<br> 46．RLC A                   1                        1                        将累加器含进位C左移一位<br> 47．RR A                    1                        1                        将累加器的值右移一位<br> 48．RRC A                   1                        1                        将累加器含进位C右移一位<br> 49．SWAP A               1                        1                        将累加器的高4位与低4位的内容交换。(A)3-0←(A)7-4<br> 数据转移指令<br> 50．MOV A,Rn              1                        1                        将寄存器的内容载入累加器<br> 51．MOV A,direct        2                        1                        将直接地址的内容载入累加器<br> 52．MOV A,@Ri             1                        1                        将间接地址的内容载入累加器<br> 53．MOV A,#data        2                        1                        将常数载入累加器<br> 54．MOV Rn，A           1                         1                         将累加器的内容载入寄存器<br> 55．MOV Rn,direct       2                         2                         将直接地址的内容载入寄存器<br> 56．MOV Rn,gdata        2                         1                         将常数载入寄存器<br> 57．MOV direct,A            2                         1                         将累加器的内容存入直接地址<br> 58．MOV direct,Rn       2                         2                         将寄存器的内容存入直接地址<br> 59．MOV direct1, direct2     3                         2                         将直接地址2的内容存入直接地址1<br> 60．MOV direct,@Ri           2                         2                         将间接地址的内容存入直接地址<br> 61．MOV direct,#data      3                         2                         将常数存入直接地址<br> 62．MOV @Ri,A             1                         1                         将累加器的内容存入某间接地址<br> 63．MOV @Ri,direct       2                         2                         将直接地址的内容存入某间接地址<br> 64．MOV @Ri,#data       2                         1                         将常数存入某间接地址<br> 65．MOV DPTR,#data16  3                         2                         将16位的常数存入数据指针寄存器<br> 66．MOVC A,@A+DPTR   1                         2                         (A) ←((A)+(DPTR))<br> 累加器的值再加数据指针寄存器的值为其所指定地址，将该地址的内容读入累加器<br> 67．MOVC A,@A+PC        1                         2                         (PC)←(PC)+1；(A)←((A)+(PC))累加器的值加程序计数器的值作为其所指定地址，将该地址的内容读入累加器<br> 68．MOVX A,@Ri             1                         2                         将间接地址所指定外部存储器的内容读入累加器(8位地址)<br> 69．MOVX A,@DPTR        1                         2                         将数据指针所指定外部存储器的内容读入累加器(16位地址)<br> 70．MOVX @Ri,A             1                         2                         将累加器的内容写入间接地址所指定的外部存储器(8位地址)<br> 71．MOVX @DPTR,A        1                         2                         将累加器的内容写入数据指针所指定的外部存储器(16位地址)<br> 72．PUSH direct                2                         2                         将直接地址的内容压入堆栈区<br> 73．POP direct                 2                         2                         从堆栈弹出该直接地址的内容<br> 74．XCH A,Rn                   1                         1                         将累加器的内容与寄存器的内容互换<br> 75．XCH A,direct             2                         1                         将累加器的值与直接地址的内容互换<br> 76．XCH A,@Ri                1                         1                         将累加器的值与间接地址的内容互换<br> 77．XCHD A,@Ri             1                         1                         将累加器的低4位与间接地址的低4位互换<br> 布尔代数运算<br> 78．CLR C                        1                         1                         清除进位C为0<br> 79．CLR bit                      2                         1                         清除直接地址的某位为0<br> 80．SETB C                       1                         1                         设定进位C为1<br> 81．SETB bit                    2                         1                         设定直接地址的某位为1<br> 82．CPL C                        1                         1                         将进位C的值反相<br> 83．CPL bit                      2                         1                         将直接地址的某位值反相<br> 84．ANL C,bit                 2                         2                         将进位C与直接地址的某位做AND的逻辑判断，结果存回进位C<br> 85．ANL C,/bit                 2                         2                         将进位C与直接地址的某位的反相值做AND的逻辑判断，结果存回进位C<br> 86．ORL C,bit                 2                           2                         将进位C与直接地址的某位做OR的逻辑判断，结果存回进位C<br> 87．ORL C,/bit                 2                        2                         将进位C与直接地址的某位的反相值做OR的逻辑判断，结果存回进位C<br> 88．MOV C,bit                 2                         1                         将直接地址的某位值存入进位C<br> 89．MOV bit,C                 2                         2                         将进位C的值存入直接地址的某位<br> 90．JC rel                           2                         2                         若进位C=1则跳至rel的相关地址<br> 91．JNC rel                      2                         2                         若进位C=0则跳至rel的相关地址<br> 92．JB bit,rel                     3                         2                         若直接地址的某位为1，则跳至rel的相关地址<br> 93．JNB bit,rel                3                         2                         若直接地址的某位为0，则跳至rel的相关地址<br> 94．JBC bit,rel                3                         2                         若直接地址的某位为1，则跳至rel的相关地址，并将该位值清除为0<br> 程序跳跃<br> 95．ACALL addr11         2                        2                        调用2K程序存储器范围内的子程序<br> 96．LCALL addr16         3                        2                        调用64K程序存储器范围内的子程序<br> 97．RET                            1                        2                        从子程序返回<br> 98．RETI                           1                        2                        从中断子程序返回<br> 99．AJMP addr11           2                         2                         绝对跳跃(2K内)<br> 100．LJMP addr16          3                         2                         长跳跃(64K内)<br> 101．SJMP rel                   2                         2                         短跳跃(2K内)-128～+127字节<br> 102．JMP @A+DPTR        1                         2                         跳至累加器的内容加数据指针所指的相关地址<br> 103．JZ rel                          2                         2                         累加器的内容为0，则跳至rel所指相关地址<br> 104．JNZ rel                       2                         2                         累加器的内容不为0，则跳至rel所指相关地址<br> 105．CJNE A,direct,rel      3                         2                         将累加器的内容与直接地址的内容比较，不相等则跳至rel所指的相关地址<br> 106．CJNE A,#data,rel       3                         2                         将累加器的内容与常数比较，若不相等则跳至rel所指的相关地址<br> 107．CJNE @Rn,#data,rel     3                         2                         将寄存器的内容与常数比较，若不相等则跳至rel所指的相关地址<br> 108．CJNE @Ri,#data,rel     3                         2                         将间接地址的内容与常数比较，若不相等则跳至rel所指的相关地址<br> 109．DJNZ Rn,rel                2                         2                         将寄存器的内容减1，不等于0则跳至rel所指的相关地址<br> 110．DJNZ direct,rel          3                          2                         将直接地址的内容减1，不等于0则跳至rel所指的相关地址<br> 111．NOP                         1                             1                         无动作</p>
]]></content>
  </entry>
  <entry>
    <title>Shell基本语法</title>
    <url>/2020/09/11/page-4/</url>
    <content><![CDATA[<p>指向解释器 #!/bin/bash (可用其他解释器，不写时默认调用bash)</p>
<p>打印 echo”输出内容”</p>
<p>定义变量 例 i=0</p>
<p>调用变量 例 echo $i</p>
<p>运算     例 echo $[$a+$b] (推荐)</p>
<p>​          echo $(($a+$b))</p>
<p>​           expr $a + $b</p>
<p>条件    例 [ $a = $b ] （条件非空为true，空为false，例 [ asd ] 为true）</p>
<p>常用判断条件</p>
<p>（1）整数间比较</p>
<p>= 字符串比较</p>
<p>-lt 小于（less than）</p>
<p>-le 小于等于 （less equal）</p>
<p>-eq 等于 （equal）</p>
<p>-gt 大于（greater than） </p>
<p>-ge 大于等于 （greater equal）</p>
<p>-ne 不等于 （not equal）</p>
<p>（2）文件权限判断</p>
<p>  -r 有读权限 （read）</p>
<p>  -w 有写权限 （write）</p>
<p>  -x 有执行权限 （execute）</p>
<p>（3）文件类型判断</p>
<p>-f 文件存在且为常规文件（file）</p>
<p>-e 文件存在（existence）</p>
<p>-d 文件存在且为目录（directory）</p>
<p>预定义变量：</p>
<p>$HOME 家目录</p>
<p>$PWD 当前目录</p>
<p>$USER 当前用户</p>
<p>$SHELL 当前解释器</p>
<p>系统变量</p>
<p>$n  （n为1-9,10以上用${n}）</p>
<p>$#    变量个数</p>
<p>例 $1 = args[0]</p>
<p>  $# = args.length</p>
<p>$*     所有参数（看作整体）</p>
<p>$@   所有参数（单独区分）</p>
<p>$?    状态码（0为正常运行）</p>
<p>readonly 设置变量只读，不可改变</p>
<p>unset 撤销变量（不可撤销readonly变量）</p>
<p>if判断</p>
<p>基本语法：</p>
<p>if[ 判断判断式 ],then</p>
<p> 程序</p>
<p>fi</p>
<p>或</p>
<p>if[ 判断判断式 ]</p>
<p> then</p>
<p>  程序</p>
<p>elif[ 判断判断式 ]</p>
<p> then</p>
<p>  程序</p>
<p>else</p>
<p> 程序</p>
<p>fi</p>
<p>case语句</p>
<p>基本语法：</p>
<p>case $变量名 in</p>
<p>  “值1”)</p>
<p>  如果变量值等于值1，执行程序1</p>
<p>  ;;</p>
<p>  “值2”)</p>
<p>  如果变量值等于值2，执行程序2</p>
<p>  ;;</p>
<p>……省略</p>
<p>  *)</p>
<p>  如果变量值不为以上值，执行此程序</p>
<p>  ;;</p>
<p>esac</p>
<p>for循环</p>
<p>基本语法：</p>
<p>for((初始值;循环控制条件;变量变化 ))</p>
<p>  do</p>
<p>​     程序</p>
<p>  done</p>
<p>基本语法2</p>
<p>for 变量 in 值1 值2 值3…</p>
<p>  do</p>
<p>​     程序</p>
<p>  done</p>
<p>while循环</p>
<p>基本语法：</p>
<p>while[ 条件判断式 ]</p>
<p>  do</p>
<p>​     程序</p>
<p>  done</p>
<p>read读取控制台输入</p>
<p>基本语法</p>
<p>read(选项)(参数)</p>
<p>选项：</p>
<p>  -p 指定读取值时的提示符</p>
<p>  -t 指定读取值时的等待时间</p>
<p>函数</p>
<p>基本语法：</p>
<p>function functionname() (可省略function或括号的其中一个，不可同时省略)</p>
<p>{</p>
<p>  函数内容;</p>
<p>}</p>
<p>函数的参数调用</p>
<p>例：</p>
<p>function plus()</p>
<p>{</p>
<p>  echo$[$1+$2]</p>
<p>}</p>
<p>plus 1 2</p>
<p><strong>Shell工具：</strong></p>
<p>1.cut</p>
<p>cut命令从文件的每一行剪切字节、字符、字段并输出</p>
<p>基本用法：</p>
<p>cut[选项参数] filename</p>
<p>参数：</p>
<p>-f 列号，提取第几列</p>
<p>-d 分隔符，按照指定分隔符分割列</p>
<p>-c 指定具体的字符（第几个字符）</p>
<p>2.sed</p>
<p>流处理编辑器，逐行处理输出，本身不会改变文件内容，除非使用重定向存储输出</p>
<p>基本用法：</p>
<p>sed[参数选项] ‘command’ filename</p>
<p>参数：</p>
<p>-e 直接在指令列模式上进行sed的动作编辑</p>
<p>-i 直接编辑文件</p>
<p>命令：（命令前接行号，可通过逗号划分多行，也可使用正则表达式）</p>
<p>a 新增，在a后面可接字串没在下一行出现</p>
<p>d 删除</p>
<p>s 查找并替换（使用正则表达式划分 例sed ‘3s/原内容/替换内容/g’ g表示全局替换）</p>
<p>正则规则：</p>
<p>\ 转义</p>
<p>^ 一行的开头</p>
<p>  ^R表示以R开头的行</p>
<p>$ 一行的结束</p>
<p>  R$表示以R结尾的行</p>
<p>* 表示上一个子式匹配0次或多次，贪心匹配</p>
<p>  Zo* </p>
<p>​       Z</p>
<p>​       Zo</p>
<p>​       Zooo</p>
<p>. 匹配一个任意字符</p>
<p>  .*匹配任意字符串</p>
<p>[] 表示匹配某个范围内的字符</p>
<p>  [a-z] 匹配一个a-z之间的字符</p>
<p>   [a-z]* 匹配任意字母字符串</p>
<p>（使用正则表达式需要用斜杠括起来）</p>
<p>3.awk</p>
<p>文本分析工具，把文本逐行读入，以空格为默认分隔符将每行切片，切开的部分再进行分析处理</p>
<p>基本用法</p>
<p>awk[选项参数] ‘pattem1{action1} pattem2{action2}…’ filename</p>
<p>pattem:表示AWK在数据中查找的内容（匹配模式）</p>
<p>action：在找到匹配内容时所执行的一系列命令</p>
<p>参数：</p>
<p>-F 指定输入文件拆分隔符</p>
<p>-v 赋值一个用户定义变量</p>
<p>BEGIN 数据到来之前先执行</p>
<p>END 数据处理完毕后执行</p>
<p>例：’BEGIN{print “BEGIN”}END{print”END”}’</p>
<p>内置变量：</p>
<p>FILENAME 文件名</p>
<p>NR 已读记录数</p>
<p>NF 浏览记录的域的个数（切割后，列的个数）</p>
<p>4.sort</p>
<p>将文件进行排序，并将结果标准输出</p>
<p>基本语法：</p>
<p>sort(选项)(参数)</p>
<p>参数</p>
<p>-n 依照数值大小排序</p>
<p>-r 以相反顺序排序</p>
<p>-t 设置排序时所用分隔字符</p>
<p>-k 设定需要排序的列</p>
]]></content>
  </entry>
  <entry>
    <title>社会工程学攻击解析</title>
    <url>/2020/05/10/page-1/</url>
    <content><![CDATA[<p>社会工程学攻击是一种通过对被攻击者心理弱点、本能反应、好奇心、信任、贪婪等心理陷阱所采取的诸如欺骗、伤害等危害手段，获取自身利益的手法。当黑客攻击与社会工程学攻击融为一体时，将根本不存在所谓安全的系统，所谓“No patch for stupid”</p>
<p>1.对特定的环境实施渗透，是社工为了获取所需敏感信息的常用手段之一。黑客通过观察被攻击者对电子邮件的响应速度、重视程度以及与被攻击者相关的资料，如个人姓名、生日、电话号码、电子邮箱地址等，通过对搜集的信息进行综合利用，进而判断被攻击的账号密码等大致内容</p>
<p>2.伪装欺骗也是社工的主要手段之一。电子邮件伪造、网络钓鱼等攻击手法均可实现伪造欺骗被攻击者，可实现诱惑被攻击者进入指定页面下载并运行恶意程序，或是要求被攻击者输入敏感账号密码等信息进行“验证”等，黑客利用被攻击者疏于防范的心理引诱用户进而实现伪装欺骗的目的</p>
<p>3.说服是对互联网信息安全危害较大的一种社工方法。它要求被攻击者与攻击者达成某种一致，进而为黑客攻击过程提供各种便利条件，当被攻击者的利益与黑客的利益没有冲突时，甚至与黑客的利益一致时，该种手段就会非常有效</p>
<p>4.黑客在实施社工的过程中，常会利用被攻击者对安全、漏洞、病毒等内容的敏感性，以权威机构的身份出现，散布安全警告、系统风险等消息，用危言耸听的伎俩恐吓、欺骗被攻击者，并声称不按照他们的方式去处理就会造成非常严重的危害和损失，借此实现对被攻击者敏感信息的获取</p>
<p>5.社工手段高明的黑客需要精通心理学、人际关系学、行为学等知识和技能，善于利用人们的本能反应、好奇心、盲目信任、贪婪等弱点设置陷阱，实施欺骗，并控制他人为己服务。他们通常十分友善，讲究说话的艺术，知道如何借助机会去恭维他人，投其所好，使多数人友善地做出回应</p>
]]></content>
  </entry>
  <entry>
    <title>XSS与CSRF的区别</title>
    <url>/2020/09/21/page-5/</url>
    <content><![CDATA[<p>1.CSRF的基本概念、缩写、全称</p>
<p>CSRF（Cross-site request forgery）：跨站请求伪造。PS：中文名一定要记住。英文全称，如果记不住也拉倒。</p>
<p>2.CSRF的攻击原理</p>
<p>用户是网站A的注册用户，且登录进去，于是网站A就给用户下发cookie。从上图可以看出，要完成一次CSRF攻击，受害者必须满足两个必要的条件：</p>
<p>（1）登录受信任网站A，并在本地生成Cookie。（如果用户没有登录网站A，那么网站B在诱导的时候，请求网站A的api接口时，会提示你登录）</p>
<p>（2）在不登出A的情况下，访问危险网站B（其实是利用了网站A的漏洞）。我们在讲CSRF时，一定要把上面的两点说清楚。温馨提示一下，cookie保证了用户可以处于登录状态，但网站B其实拿不到 cookie。</p>
<p>3、CSRF如何防御</p>
<p>方法一、Token 验证：（用的最多）</p>
<p>（1）服务器发送给客户端一个token；</p>
<p>（2）客户端提交的表单中带着这个token。</p>
<p>（3）如果这个 token 不合法，那么服务器拒绝这个请求。</p>
<p>方法二：隐藏令牌：把 token 隐藏在 http 的 head头中。方法二和方法一有点像，本质上没有太大区别，只是使用方式上有区别。方法三、Referer 验证：Referer 指的是页面请求来源。意思是，只接受本站的请求，服务器才做响应；如果不是，就拦截。</p>
<p>XSS</p>
<p>1、XSS的基本概念</p>
<p>XSS（Cross Site Scripting）：跨域脚本攻击。XSS的攻击原理XSS攻击的核心原理是：不需要你做任何的登录认证，它会通过合法的操作（比如在url中输入、在评论框中输入），向你的页面注入脚本（可能是js、hmtl代码块等）。最后导致的结果可能是：盗用Cookie破坏页面的正常结构，插入广告等恶意内容D-doss攻击XSS的攻击方式1、反射型发出请求时，XSS代码出现在url中，作为输入提交到服务器端，服务器端解析后响应，XSS代码随响应内容一起传回给浏览器，最后浏览器解析执行XSS代码。这个过程像一次反射，所以叫反射型XSS。</p>
<p>2、存储型存储型XSS和反射型XSS的差别在于，提交的代码会存储在服务器端（数据库、内存、文件系统等），下次请求时目标页面时不用再提交XSS代码。</p>
<p>XSS的防范措施（encode + 过滤）</p>
<p>XSS的防范措施主要有三个：</p>
<p>1、编码：对用户输入的数据进行HTML Entity 编码。如上图所示，把字符转换成 转义字符。Encode的作用是将$var等一些字符进行转化，使得浏览器在最终输出结果上是一样的。比如说这段代码：<script>alert(1)</script>若不进行任何处理，则浏览器会执行alert的js操作，实现XSS注入。进行编码处理之后，L在浏览器中的显示结果就是<script>alert(1)</script>，实现了将$var作为纯文本进行输出，且不引起JavaScript的执行。</p>
<p>2、过滤：移除用户输入的和事件相关的属性。如onerror可以自动触发攻击，还有onclick等。（总而言是，过滤掉一些不安全的内容）移除用户输入的Style节点、Script节点、Iframe节点。（尤其是Script节点，它可是支持跨域的呀，一定要移除）。</p>
<p>3、校正避免直接对HTML Entity进行解码。使用DOM Parse转换，校正不配对的DOM标签。备注：我们应该去了解一下DOM Parse这个概念，它的作用是把文本解析成DOM结构。比较常用的做法是，通过第一步的编码转成文本，然后第三步转成DOM对象，然后经过第二步的过滤。还有一种简洁的答案：首先是encode，如果是富文本，就白名单。</p>
<p>CSRF 和 XSS 的区别</p>
<p>区别一：CSRF：需要用户先登录网站A，获取 cookie。XSS：不需要登录。</p>
<p>区别二：（原理的区别）CSRF：是利用网站A本身的漏洞，去请求网站A的api。XSS：是向网站 A 注入 JS代码，然后执行 JS 里的代码，篡改网站A的内容。</p>
]]></content>
  </entry>
  <entry>
    <title>运维学习建议</title>
    <url>/2020/10/04/linux1/</url>
    <content><![CDATA[<h2 id="一、学习Linux的注意事项"><a href="#一、学习Linux的注意事项" class="headerlink" title="一、学习Linux的注意事项"></a>一、学习Linux的注意事项</h2><h3 id="1-Linux严格区分大小写"><a href="#1-Linux严格区分大小写" class="headerlink" title="1.Linux严格区分大小写"></a>1.Linux严格区分大小写</h3><p>Linux是严格区分大小写的，这一点和Windows不一样，所以操作时要注意区分大小写的不同，包括文件名和目录名、命令、命令选项、配置文件设置选项等。</p>
<h3 id="2-Linux一切皆文件"><a href="#2-Linux一切皆文件" class="headerlink" title="2. Linux一切皆文件"></a>2. Linux一切皆文件</h3><p>Linux中所有内容都是以文件的形式保存和管理的，硬件设备也是文件，这和Windows完全不同，Windows是通过设备管理器来管理硬件的。Linux的设备文件保存在/dev/目录中，硬盘文件是/dev/sd[a-p]，光盘文件是/dev/hdc等。</p>
<h3 id="3-Linux不靠扩展名区分文件类型"><a href="#3-Linux不靠扩展名区分文件类型" class="headerlink" title="3.Linux不靠扩展名区分文件类型"></a>3.Linux不靠扩展名区分文件类型</h3><p>Windows是依赖扩展名区分文件类型的，比如，“.txt”是文本文件、“.exe”是执行文件、“.ini”是配置文件、“.mp4”是小电影等。但Linux不是靠扩展名区分文件类型的，而是靠权限位标识来确定文件类型的，而且文件类型的种类也不像Windows下那么多，常见的文件类型只有普通文件、目录、链接文件、块设备文件、字符设备文件等几种。Linux的可执行文件不过就是普通文件被赋予了可执行权限而已。</p>
<p>但Linux中的一些特殊文件还是要求写“扩展名”的，但是大家小心，并不是Linux一定要靠扩展名来识别文件类型，写这些扩展名是为了帮助管理员来区分不同的文件类型。这样的文件扩展名主要有以下几种。</p>
<ul>
<li><p>压缩包：Linux下常见的压缩文件名有<em>.gz、</em>.bz2、<em>.zip、</em> . t a r. g z、<em>.tar.bz2、</em>.tgz等。为什么压缩包一定要写扩展名呢？其实很好理解，如果不写清楚扩展名，那么管理员不容易判断压缩包的格式，虽然有命令可以帮助判断，但是直观一点更加方便。另外，就算没写扩展名，在Linux中一样可以解压缩，不影响使用。</p>
</li>
<li><p>二进制软件包：CentOS中所使用的二进制安装包是RPM包，所有的RPM包都用“.rpm”扩展名结尾，目的同样是让管理员一目了然。</p>
</li>
<li><p>程序文件：Shell脚本一般用“<em>.sh”扩展名结尾，其他还有用“</em>.c”扩展名结尾的C语言文件等。</p>
</li>
<li><p>网页文件：网页文件一般使用“<em>.html”“</em>.php”等结尾，不过这是网页服务器的要求，而不是Linux的要求。</p>
</li>
</ul>
<h3 id="4．Linux中所有的存储设备都必须在挂载之后才能使用"><a href="#4．Linux中所有的存储设备都必须在挂载之后才能使用" class="headerlink" title="4．Linux中所有的存储设备都必须在挂载之后才能使用"></a>4．Linux中所有的存储设备都必须在挂载之后才能使用</h3><p>Linux中所有的存储设备都有自己的设备文件名，这些设备文件必须在挂载之后才能使用，包括硬盘、U盘和光盘。挂载其实就是给这些存储设备分配盘符，只不过Windows中的盘符用英文字母表示 ，而Linux中的盘符则是一个已经建立的空目录。我们把这些空目录叫作挂载点（可以理解为Windows的盘符），把设备文件（如/dev/sdb）和挂载点（已经建立的空目录）连接的过程叫作挂载</p>
<h3 id="5．Windows下的程序不能直接在Linux中使用"><a href="#5．Windows下的程序不能直接在Linux中使用" class="headerlink" title="5．Windows下的程序不能直接在Linux中使用"></a>5．Windows下的程序不能直接在Linux中使用</h3><p>Linux和Windows是不同的操作系统，可以安装和使用的软件也是不同的，所以能够在Windows中安装的软件是不能在Linux中安装的。有好处吗？当然有，那就是能够感染Windows的病毒和木马都对Linux无效。有坏处吗？也有，那就是所有的软件要想在Linux中安装，必须单独开发针对Linux的版本，或者依赖模拟器软件运行。很多软件也会同时推出针对Windows和Linux的版本，如大家熟悉的即时通信软件QQ。</p>
<h2 id="二、服务器管理建议"><a href="#二、服务器管理建议" class="headerlink" title="二、服务器管理建议"></a>二、服务器管理建议</h2><h3 id="1．了解Linux目录结构"><a href="#1．了解Linux目录结构" class="headerlink" title="1．了解Linux目录结构"></a>1．了解Linux目录结构</h3><table>
<thead>
<tr>
<th>目录名</th>
<th>目录的作用</th>
</tr>
</thead>
<tbody><tr>
<td>/bin/</td>
<td>存放系统命令的目录，普通用户和超级用户都可以执行。是/usr/bin/目录的软链接</td>
</tr>
<tr>
<td>/sbin/</td>
<td>存放系统  命令的目录，只有超级用户才可以执行。是/usr/sbin/目录的软链接</td>
</tr>
<tr>
<td>/usr/bin/</td>
<td>存放系统命令的目录，普通用户和超级用户都可以执行</td>
</tr>
<tr>
<td>/usr/sbin/</td>
<td>存放系统  命令的目录，只有超级用户才可以执</td>
</tr>
<tr>
<td>/boot/</td>
<td>系统启动目录，保存与系统启动相关的文件，如内核文件和启动引导程序（grub）文件等</td>
</tr>
<tr>
<td>/dev/</td>
<td>设备文件保存位置</td>
</tr>
<tr>
<td>/etc/</td>
<td>配置文件保存位置。系统内所有采用默认安装方式（rpm安装）的服务配置文件全部保存在此目录中，如用户信息、服务的启动脚本、常用服务的配置文件等</td>
</tr>
<tr>
<td>/home/</td>
<td>普通用户的家目录。在创建用户时，每个用户要有一个默认登录和保存自己数据的位置，就是用户的家目录，所有普通用户的宿主目录是在/home/下建立一个和用户名相同的目录。如用户user1的家目录就是/home/user1/</td>
</tr>
<tr>
<td>/lib/</td>
<td>系统调用的函数库保存位置。是/usr/lib/的软链接</td>
</tr>
<tr>
<td>/lib64/</td>
<td>64位函数库保存位置。是/usr/lib64/的软链接</td>
</tr>
<tr>
<td>/lost+found/</td>
<td>当系统意外崩溃或机器意外关机，而产生一些文件碎片放在这里。当系统启动的过程中fsck工具会检查这里，并修复已经损坏的文件系统。这个目录只在每个分区中出现，例如/lost+found就是根分区的备份恢复目录，/boot/lost+found就是/boot分区的备份恢复目录</td>
</tr>
<tr>
<td>/media/</td>
<td>挂载目录。系统建议是用来挂载媒体设备的，如软盘和光盘</td>
</tr>
<tr>
<td>/misc/</td>
<td>挂载目录。系统建议用来挂载NFS服务的共享目录。我们在刚刚已经解释了挂载，童鞋们应该知道只要是一个已经建立的空目录就可以作为挂载点。那么系统虽然准备了三个默认挂载目录/media、/mnt、/misc，但是到底在哪个目录中挂载什么设备都可以由管理员自己决定。例如超哥接触Linux的时候，默认挂载目录只有/mnt一个，所以养成了在/mnt下建立不同目录挂载不同设备的习惯。如/mnt/cdrom挂载光盘，/mnt/usb挂载U盘，这都是可以的</td>
</tr>
<tr>
<td>/mnt/</td>
<td>挂载目录。早期Linux中只有这一个挂载目录，并没有细分。现在系统建议这个目录用来挂载额外的设备，如U盘、移动硬盘和其他操作系统的分区</td>
</tr>
<tr>
<td>/opt/</td>
<td>第三方安装的软件保存位置。这个目录是放置和安装其他软件的位置，手工安装的源码包软件都可以安装到这个目录中。不过超哥还是习惯把软件放到/usr/local/目录中，也就是说，/usr/local/目录也可以用来安装软件</td>
</tr>
<tr>
<td>/proc/</td>
<td>虚拟文件系统。该目录中的数据并不保存在硬盘上，而是保存到内存中。主要保存系统的内核、进程、外部设备状态和网络状态等。如/proc/cpuinfo是保存CPU信息的，/proc/devices是保存设备驱动的列表的，/proc/filesystems是保存文件系统列表的，/proc/net是保存网络协议信息的…..</td>
</tr>
<tr>
<td>/sys/</td>
<td>虚拟文件系统。和/proc/目录相似，该目录中的数据都保存在内存中，主要保存与内核相关的信息</td>
</tr>
<tr>
<td>/root/</td>
<td>root的宿主目录。普通用户宿主目录在/home/下，root宿主目录直接在“/”下</td>
</tr>
<tr>
<td>/run/</td>
<td>系统运行时产生的数据，如ssid，pid等相关数据。/var/run/是此目录的软链接</td>
</tr>
<tr>
<td>/srv/</td>
<td>服务数据目录。一些系统服务启动之后，可以在这个目录中保存所需要的数据</td>
</tr>
<tr>
<td>/tmp/</td>
<td>临时目录。系统存放临时文件的目录，在该目录下，所有用户都可以访问和写入。我们建议此目录中不能保存重要数据，最好每次开机都把该目录清空</td>
</tr>
<tr>
<td>/usr/</td>
<td>系统软件资源目录。注意usr不是user的缩写，而是“UNIX Software Resource”的缩写，所以不是存放用户数据的目录，而是存放系统软件资源的目录。系统中安装的软件大多数保存在这里</td>
</tr>
<tr>
<td>/usr/lib/</td>
<td>应用程序调用的函数库保存位置</td>
</tr>
<tr>
<td>/usr/local/</td>
<td>手工安装的软件保存位置。我们一般建议源码包软件安装在这个位置</td>
</tr>
<tr>
<td>/usr/share/</td>
<td>应用程序的资源文件保存位置，如帮助文档、说明文档和字体目录</td>
</tr>
<tr>
<td>/usr/src/</td>
<td>源码包保存位置。我们手工下载的源码包和内核源码包都可以保存到这里。不过超哥更习惯把手工下载的源码包保存到/usr/local/src/目录中，把内核源码保存到/usr/src/kernels/目录中</td>
</tr>
<tr>
<td>/usr/src/kernels/</td>
<td>内核源码保存位置</td>
</tr>
<tr>
<td>/var/</td>
<td>动态数据保存位置。主要保存缓存、日志以及软件运行所产生的文件</td>
</tr>
<tr>
<td>/var/www/html/</td>
<td>RPM包安装的Apache的网页主目录</td>
</tr>
<tr>
<td>/var/lib/</td>
<td>程序运行中需要调用或改变的数据保存位置。如MySQL的数据库保存在/var/lib/mysql/目录中</td>
</tr>
<tr>
<td>/var/log/</td>
<td>系统日志保存位置</td>
</tr>
<tr>
<td>/var/run/</td>
<td>一些服务和程序运行后，它们的PID（进程ID）保存位置。是/run/目录的软链接</td>
</tr>
<tr>
<td>/var/spool/</td>
<td>放置队列数据的目录。就是排队等待其他程序使用的数据，比如邮件队列和打印队列</td>
</tr>
<tr>
<td>/var/spool/mail/</td>
<td>新收到的邮件队列保存位置。系统新收到的邮件会保存在此目录中</td>
</tr>
<tr>
<td>/var/spool/cron/</td>
<td>系统的定时任务队列保存位置。系统的计划任务会保存在这里</td>
</tr>
</tbody></table>
<h3 id="2-远程服务器关机及重启时的注意事项"><a href="#2-远程服务器关机及重启时的注意事项" class="headerlink" title="2.远程服务器关机及重启时的注意事项"></a>2.远程服务器关机及重启时的注意事项</h3><p>为什么远程服务器不能关机呢？很简单，远程服务器没有放置在本地，关机后，谁可以帮你按开机电源键启动服务器？虽然计算机技术日新月异，但是像插入电源和开机这样的工作还是需要手工进行的。如果服务器在远程，一旦关机，就只能求助托管机房的管理人员帮你开机了。远程服务器重启时需要注意两点。</p>
<h4 id="2-1远程服务器在重启前，要中止正在执行的服务"><a href="#2-1远程服务器在重启前，要中止正在执行的服务" class="headerlink" title="2.1远程服务器在重启前，要中止正在执行的服务"></a>2.1远程服务器在重启前，要中止正在执行的服务</h4><p>计算机的硬盘最怕在高速存储时断电或重启，非常容易造成硬盘损坏。所以，在重启前先中止你的服务，甚至可以考虑暂时断开对外提供服务的网络。可能你会觉得服务器有这么娇贵吗？我的笔记本电脑经常强行关机，也没有发现硬盘损坏啊？这是因为你的个人计算机没有很多人访问，强制断电时硬盘并没有进行数据交换。小心驶得万年船！</p>
<h4 id="2-2重启命令的选用"><a href="#2-2重启命令的选用" class="headerlink" title="2.2重启命令的选用"></a>2.2重启命令的选用</h4><p>Linux可以识别的重启命令有很多条，但是建议大家使用“shutdown -r now”命令重启。这条命令在重启时会正常保存和中止服务器中正在运行的程序，是安全重启命令。而且最好在重启前执行几次“sync”命令，这条命令是数据同步命令，可以让暂时保存在内存中的数据同步到硬盘上。</p>
<h3 id="3．不要在服务器访问高峰运行高负载命令"><a href="#3．不要在服务器访问高峰运行高负载命令" class="headerlink" title="3．不要在服务器访问高峰运行高负载命令"></a>3．不要在服务器访问高峰运行高负载命令</h3><p>这一点大家很好理解，在服务器访问高峰，如果使用一些对服务器压力较大的命令，则有可能会造成服务器响应缓慢甚至死机。哪些命令是高负载命令呢？其实，如果大家使用过Windows操作系统，则也会留意到一些操作会给计算机带来较大的运算压力，道理都是一样的，如复制大量的数据、压缩或者解压缩大文件、大范围的硬盘搜索等。什么时间算作访问高峰期呢？我们一般认为17:00—24:00算作访问高峰期。当然，每台服务器具体提供的服务不同，访问高峰期有时也会有所出入。比如，服务器主要是供美国人民访问的，那就要考虑时差的问题；或者服务器提供的服务很特殊，访问高峰期可能也不同。一般我们建议在凌晨4:00—5:00执行这些命令。那是不是说我们需要在凌晨上班？当然不是，这谁受得了啊？我们可以使用系统的计划任务，让操作自动在指定的时间段执行。</p>
<h3 id="4．远程配置防火墙时不要把自己踢出服务器"><a href="#4．远程配置防火墙时不要把自己踢出服务器" class="headerlink" title="4．远程配置防火墙时不要把自己踢出服务器"></a>4．远程配置防火墙时不要把自己踢出服务器</h3><p>简单来讲，防火墙就是根据数据包自身的参数来判断是否允许数据包通过的网络设备。我们的服务器要想在公网中安全地使用，就需要使用防火墙过滤有害的数据包。但是在配置防火墙时，如果管理员对防火墙不是很熟悉，则有可能把自己的正常访问数据包和有害数据包全部过滤掉，导致自己也无法正常登录服务器，如防火墙关闭了远程连接的SSH服务的端口。防火墙配置完全是靠手工命令完成的，配置规则和配置命令相对也比较复杂，万一设置的时候心不在焉，悲剧就发生了。如何避免这种尴尬的情况发生呢？最好的方法当然是在服务器本地配置防火墙，这样就算不小心把自己的远程登录给过滤了，还可以通过本机登录来进行恢复。如果服务器已经在远程登录了，要配置防火墙，那么最好在本地测试完善后再进行上传，这样会把发生故障的概率降到最低。虽然在本地测试好了，但是传到远程服务器上时仍有可能发生问题。于是超哥想到一个笨办法：如果需要远程配置防火墙，那么先写一个系统定时任务，让它每5分钟清空一下防火墙规则，就算写错了也还有反悔的机会，等测试没有问题了再删除这个系统定时任务</p>
<h3 id="5．指定合理的密码规范并定期更新"><a href="#5．指定合理的密码规范并定期更新" class="headerlink" title="5．指定合理的密码规范并定期更新"></a>5．指定合理的密码规范并定期更新</h3><p>前面我们介绍了设置密码需要遵守复杂性、易记忆性和时效性的三原则，这里就不再重复解释了。</p>
<h3 id="6．合理分配权限"><a href="#6．合理分配权限" class="headerlink" title="6．合理分配权限"></a>6．合理分配权限</h3><p>服务器管理有一个最简单的原则：给予用户最小的权限。</p>
<h3 id="7．定期备份重要数据和日志"><a href="#7．定期备份重要数据和日志" class="headerlink" title="7．定期备份重要数据和日志"></a>7．定期备份重要数据和日志</h3><p>备份的基本原则：不要把鸡蛋放在同一个篮子里</p>
]]></content>
      <tags>
        <tag>linux运维基础</tag>
      </tags>
  </entry>
  <entry>
    <title>linux常用命令(更新中)</title>
    <url>/2020/10/04/linux2/</url>
    <content><![CDATA[<h2 id="一-、命令的基本格式"><a href="#一-、命令的基本格式" class="headerlink" title="一 、命令的基本格式"></a>一 、命令的基本格式</h2><h3 id="1-命令的提示符"><a href="#1-命令的提示符" class="headerlink" title="1.命令的提示符"></a>1.命令的提示符</h3><p><code>[root@localhost ~]#</code> </p>
<ul>
<li><p>[]：这是提示符的分隔符号，没有特殊含义。</p>
</li>
<li><p>root：显示的是当前的登录用户，超哥现在使用的是root用户登录  。</p>
</li>
<li><p>@：分隔符号，没有特殊含义。</p>
</li>
<li><p>localhost：当前系统的简写主机名（完整主机名是localhost.localdomain）。</p>
</li>
<li><p>~：代表用户当前所在的目录，此例中用户当前所在的目录是家目录。</p>
</li>
<li><p>#：命令提示符。超级用户是#，普通用户是$ </p>
</li>
</ul>
<h3 id="2-命令的基本格式"><a href="#2-命令的基本格式" class="headerlink" title="2.命令的基本格式"></a>2.命令的基本格式</h3><p><code>[root@localhost ~]# 命令[选项] [参数]</code> </p>
<p>ls是最常见的目录操作命令，主要作用是显示目录下的内容。</p>
<ul>
<li><p>命令名称：ls。英文原意：list。所在路径：/bin/ls。</p>
</li>
<li><p>执行权限：所有用户。</p>
</li>
<li><p>功能描述：显示目录下的内容。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]#ls [选项] [文件名或目录名] 选项：-a:        显示所有文件   </span><br><span class="line"></span><br><span class="line">--color&#x3D;when: 支持颜色输出，when的值默认是always（总显示颜色），也可以是                     never（从不显示颜色）和auto（自动）  </span><br><span class="line"></span><br><span class="line"> -d：显示目录信息，而不是目录下的文件  </span><br><span class="line"></span><br><span class="line"> -h：人性化显示，按照我们习惯的单位显示文件大小   </span><br><span class="line"></span><br><span class="line">-i：显示文件的i节点号   </span><br><span class="line"></span><br><span class="line">-l：长格式显示</span><br></pre></td></tr></table></figure>

<p>举几个例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# ls -l </span><br><span class="line">总用量 44 </span><br><span class="line">-rw-------. 1 root root  1207 1月    14 18:18 anaconda-ks.cfg </span><br><span class="line">#权限 引用计数 所有者 所属组 大小 文件 修改时间 文件名</span><br></pre></td></tr></table></figure>

<p>我们已经知道“-l”选项用于  显示文件的详细信息，那么“-l”选项  显示的这7列分别 是什么含义？</p>
<ul>
<li><p>第一列：权限。具体权限的含义将在4.5节中讲解。</p>
</li>
<li><p>第二列：引用计数。文件的引用计数代表该文件的硬链接个数，而目录的引用计数代表该目录有多少个一级子目录。</p>
</li>
<li><p>第三列：所有者，也就是这个文件属于哪个用户。默认所有者是文件的建立用户</p>
</li>
<li><p>第四列：所属组。默认所属组是文件建立用户的有效组，一般情况下就是建立用户的所在组。</p>
</li>
<li><p>第五列：大小。默认单位是字节。</p>
</li>
<li><p>第六列：文件修改时间。文件状态修改时间或文件数据修改时间都会更改这个时间，注意这个时间不是文件的创建时间。</p>
</li>
<li><p>第七列：文件名。</p>
<p>选项：是用于调整命令的功能的。</p>
<p>参数：是命令的操作对象，如果省略参数，是因为有默认参数</p>
</li>
</ul>
<h2 id="二、目录操作命令"><a href="#二、目录操作命令" class="headerlink" title="二、目录操作命令"></a>二、目录操作命令</h2><h3 id="1．ls命令"><a href="#1．ls命令" class="headerlink" title="1．ls命令"></a>1．ls命令</h3><p>见前一小节的内容。</p>
<h3 id="2-cd命令"><a href="#2-cd命令" class="headerlink" title="2.cd命令"></a>2.cd命令</h3><p>cd是切换所在目录的命令，这个命令的基本信息如下。</p>
<ul>
<li><p>命令名称：cd。</p>
</li>
<li><p>英文原意：change directory。</p>
</li>
<li><p>所在路径：Shell内置命令。</p>
</li>
<li><p>执行权限：所有用户。</p>
</li>
<li><p>功能描述：切换所在目录。</p>
<h4 id="2-1-cd命令的简化用法"><a href="#2-1-cd命令的简化用法" class="headerlink" title="2.1 cd命令的简化用法"></a>2.1 cd命令的简化用法</h4></li>
</ul>
<table>
<thead>
<tr>
<th>特殊符号</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>~</td>
<td>代表用户的家目录</td>
</tr>
<tr>
<td>-</td>
<td>代表上次所在目录</td>
</tr>
<tr>
<td>.</td>
<td>代表当前目录</td>
</tr>
<tr>
<td>..</td>
<td>代表上级目录</td>
</tr>
</tbody></table>
<h4 id="2-2-绝对路径和相对路径"><a href="#2-2-绝对路径和相对路径" class="headerlink" title="2.2 绝对路径和相对路径"></a>2.2 绝对路径和相对路径</h4><p>绝对路径：以跟目录为参照物，从根目录开始，一级一级进入目录</p>
<p>相对路径：以当前目录作为参照物，进行目录查找</p>
<h3 id="3．pwd命令"><a href="#3．pwd命令" class="headerlink" title="3．pwd命令"></a>3．pwd命令</h3><p>pwd命令是查询所在目录的命令，基本信息如下：</p>
<ul>
<li><p>命令名称：pwd</p>
</li>
<li><p>英文原意：print name of current/working directory</p>
</li>
<li><p>所在路径：/bin/pwd</p>
</li>
<li><p>执行权限：所有用户。</p>
</li>
<li><p>功能描述：查询所在的工作目录。</p>
</li>
</ul>
<h3 id="4．mkdir命令"><a href="#4．mkdir命令" class="headerlink" title="4．mkdir命令"></a>4．mkdir命令</h3><ul>
<li><p>mkdir是创建目录的命令，其基本信息如下。</p>
</li>
<li><p>命令名称：mkdir。</p>
</li>
<li><p>英文原意：make directories。</p>
</li>
<li><p>所在路径：/bin/mkdir。执行权限：所有用户。</p>
</li>
<li><p>功能描述：创建空目录。</p>
</li>
</ul>
<p>命令格式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# mkdir </span><br><span class="line">[选项] 目录名选项：   </span><br><span class="line">-p：递归建立所需目录</span><br></pre></td></tr></table></figure>

<p>5．rmdir命令</p>
<p>既然有建立目录的命令，就一定会有删除目录的命令</p>
<p>rmdir，其基本信息如下。</p>
<ul>
<li><p>命令名称：rmdir。</p>
</li>
<li><p>英文原意：remove empty directories。</p>
</li>
<li><p>所在路径：/bin/rmdir。</p>
</li>
<li><p>执行权限：所有用户。</p>
</li>
<li><p>功能描述：删除空目录。</p>
</li>
</ul>
<p>命令格式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# rmdir </span><br><span class="line"></span><br><span class="line">[选项] 目录名选项：   </span><br><span class="line"></span><br><span class="line">-p：递归删除目录</span><br></pre></td></tr></table></figure>

<p>rmdir命令的作用十分有限，因为只能删除空目录，所以一旦目录中有内容，就会报错。这个命令比较“笨”，所以我们不太常用。后续我们不论删除的是文件还是目录，都会使用rm命令</p>
<h2 id="三、文件操作命令"><a href="#三、文件操作命令" class="headerlink" title="三、文件操作命令"></a>三、文件操作命令</h2><h3 id="1．touch命令"><a href="#1．touch命令" class="headerlink" title="1．touch命令"></a>1．touch命令</h3><p>创建空文件或修改文件时间，这个命令的基本信息如下。</p>
<ul>
<li><p>命令名称：touch。</p>
</li>
<li><p>英文原意：change file timestamps。</p>
</li>
<li><p>所在路径：/bin/touch。</p>
</li>
<li><p>执行权限：所有用户。</p>
</li>
<li><p>功能描述：修改文件的时间戳。</p>
</li>
</ul>
<h3 id="2．stat命令"><a href="#2．stat命令" class="headerlink" title="2．stat命令"></a>2．stat命令</h3><ul>
<li><p>stat是查看文件详细信息的命令，而且可以看到文件的这三个时间，其基本信息如下。</p>
</li>
<li><p>命令名称：stat。</p>
</li>
<li><p>英文原意：display file or file system status。</p>
</li>
<li><p>所在路径：/usr/bin/stat。</p>
</li>
<li><p>执行权限：所有用户。</p>
</li>
</ul>
<p>功能描述：显示文件或文件系统的详细信息。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# stat  anaconda-ks.cfg </span><br><span class="line">文件：&quot;anaconda-ks.cfg&quot; 大小：1453      块：8          IO 块：4096   普通文件</span><br><span class="line">设备：803h&#x2F;2051d Inode：33574991    硬链接：1 </span><br><span class="line">权限：(0600&#x2F;-rw-------)  Uid：(    0&#x2F;    root)   Gid：(    0&#x2F;    root)</span><br><span class="line">环境：system_u:object_r:admin_home_t:s0 </span><br><span class="line">最近访问：2018-11-06 23:22:23.409038121 +0800 </span><br><span class="line">最近更改：2018-10-24 00:53:08.760018638 +0800 #数据修改时间</span><br><span class="line">最近改动：2018-10-24 00:53:08.760018638 +0800 #状态修改时间</span><br><span class="line">创建时间：-</span><br></pre></td></tr></table></figure>

<h3 id="3．cat命令"><a href="#3．cat命令" class="headerlink" title="3．cat命令"></a>3．cat命令</h3><p>cat命令用来查看文件内容。这个命令的基本信息如下。</p>
<ul>
<li><p>命令名称：cat。</p>
</li>
<li><p>英文原意：concatenate files and print on the standard output。</p>
</li>
<li><p>所在路径：/bin/cat。</p>
</li>
<li><p>执行权限：所有用户。</p>
</li>
</ul>
<p>功能描述：合并文件并打印输出到标准输出</p>
<p>命令格式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# cat </span><br><span class="line">[选项] 文件名选项：   -A：相当于-vET选项的整合，用于列出所有隐藏符号  </span><br><span class="line">-E：列出每行结尾的回车符$    </span><br><span class="line">-n：显示行号  </span><br><span class="line">-T：把Tab键用^I显示出来   </span><br><span class="line">-v：列出特殊字符</span><br></pre></td></tr></table></figure>

<h3 id="4．more命令"><a href="#4．more命令" class="headerlink" title="4．more命令"></a>4．more命令</h3><p>more是分屏显示文件的命令，其基本信息如下。</p>
<ul>
<li><p>命令名称：more。</p>
</li>
<li><p>英文原意：file perusal filter for crt viewin。</p>
</li>
<li><p>所在路径：/bin/more。执行权限：所有用户。</p>
</li>
<li><p>功能描述：分屏显示文件内容。</p>
</li>
</ul>
<p>more命令比较简单，一般不用什么选项，命令会打开一个交互界面，可以识别一些交互命令。常用的交互命令如下。</p>
<ul>
<li><p>空格键：向下翻页。</p>
</li>
<li><p>b：向上翻页。回车键：向下滚动一行。</p>
</li>
<li><p>/字符串：搜索指定的字符串。</p>
</li>
<li><p>q：退出  。</p>
</li>
</ul>
<h3 id="5．less命令"><a href="#5．less命令" class="headerlink" title="5．less命令"></a>5．less命令</h3><p>less命令和more命令类似，只是more是分屏显示命令，而less是分行显示命令，其基本信息如下。</p>
<ul>
<li>命令名称：less。</li>
<li>英文原意：opposite of more。</li>
<li>所在路径：/usr/bin/less。</li>
<li>执行权限：所有用户。</li>
<li>功能描述：分行显示文件内容</li>
</ul>
<h3 id="6．head命令"><a href="#6．head命令" class="headerlink" title="6．head命令"></a>6．head命令</h3><p>head是用来显示文件开头的命令，其基本信息如下。</p>
<p>命令名称：head。</p>
<p>英文原意：output the first part of files。</p>
<p>所在路径：/usr/bin/head。执行权限：所有用户。</p>
<p>功能描述：显示文件开头的内容。</p>
<p>命令格式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# head [选项] 文件名</span><br><span class="line">选项：   -n 行数：从文件头开始，显示指定行数   </span><br><span class="line">-v：显示文件名</span><br></pre></td></tr></table></figure>

<h3 id="7．tail命令"><a href="#7．tail命令" class="headerlink" title="7．tail命令"></a>7．tail命令</h3><p>既然有显示文件开头的命令，就会有显示文件结尾的命令。tail命令的基本信息如下。</p>
<p>命令名称：tail。</p>
<p>英文原意：output the last part of files。</p>
<p>所在路径：/usr/bin/tail。</p>
<p>执行权限：所有用户。</p>
<p>功能描述：显示文件结尾的内容。</p>
<p>命令格式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# tail [选项] 文件名</span><br><span class="line">选项：   </span><br><span class="line">-n 行数：从文件结尾开始，显示指定行数   </span><br><span class="line">-f：监听文件的新增内容</span><br></pre></td></tr></table></figure>

<h3 id="8．ln命令"><a href="#8．ln命令" class="headerlink" title="8．ln命令"></a>8．ln命令</h3><p>我们来看看ln命令的基本信息。</p>
<p>命令名称：ln。</p>
<p>英文原意：make links between file。</p>
<p>所在路径：/bin/ln。执行权限：所有用户。</p>
<p>功能描述：在文件之间建立链接。</p>
<h4 id="8-1ln命令的基本格式如下："><a href="#8-1ln命令的基本格式如下：" class="headerlink" title="8.1ln命令的基本格式如下："></a>8.1ln命令的基本格式如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# ln [选项] 源文件目标文件</span><br><span class="line">选项：   </span><br><span class="line">-s：建立软链接文件。如果不加“-s”选项，则建立硬链接文件   </span><br><span class="line">-f：强制。如果目标文件已经存在，则删除目标文件后再建立链接文件</span><br></pre></td></tr></table></figure>

<p>如果创建硬链接：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# touch cangls </span><br><span class="line">[root@localhost ~]# ln &#x2F;root&#x2F;cangls &#x2F;tmp&#x2F; </span><br><span class="line">#建立硬链接文件，目标文件没有写文件名，会和原名一致</span><br><span class="line">#也就是&#x2F;root&#x2F;cangls和&#x2F;tmp&#x2F;cangls是硬链接文件</span><br></pre></td></tr></table></figure>

<p>如果创建软链接：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# touch bols </span><br><span class="line">[root@localhost ~]# ln -s &#x2F;root&#x2F;bols  &#x2F;tmp&#x2F;</span><br><span class="line">#建立软链接文件</span><br></pre></td></tr></table></figure>

<h4 id="8-2-硬链接与软连接的特征"><a href="#8-2-硬链接与软连接的特征" class="headerlink" title="8.2 硬链接与软连接的特征"></a>8.2 硬链接与软连接的特征</h4><p>硬链接特征：</p>
<ul>
<li><p>源文件和硬链接文件拥有相同的Inode和Block</p>
</li>
<li><p>任意一个文件，另一个都改变</p>
</li>
<li><p>删除任意一个文件，另一个都能使用</p>
</li>
<li><p>硬链接标记不清，很难确认硬链接文件位置，不建议使用硬链接不能链接目录</p>
</li>
<li><p>硬链接不能跨分区</p>
</li>
</ul>
<p>软链接特征：</p>
<ul>
<li><p>软链接和源文件拥有不同的Inode和Block</p>
</li>
<li><p>两个文件修改任意一个，另一个都改变</p>
</li>
<li><p>删除软链接，源文件不受影响；删除源文件，软链接不能使用</p>
</li>
<li><p>软链接没有实际数据，只保存源文件的Inode，不论源文件多大，软链接大小不变</p>
</li>
<li><p>软链接的权限是最大权限lrwxrwxrwx.，但是由于没有实际数据，最终访问时需要参考源文件权限</p>
</li>
<li><p>软链接可以链接目录</p>
</li>
<li><p>软链接可以跨分区</p>
</li>
<li><p>软链接特征明显，建议使用软连接</p>
</li>
</ul>
<h2 id="四、目录和文件都能操作的命令"><a href="#四、目录和文件都能操作的命令" class="headerlink" title="四、目录和文件都能操作的命令"></a>四、目录和文件都能操作的命令</h2><h3 id="1．rm命令"><a href="#1．rm命令" class="headerlink" title="1．rm命令"></a>1．rm命令</h3><p>rm是强大的删除命令，不仅可以删除文件，也可以删除目录。这个命令的基本信息如下。</p>
<ul>
<li><p>命令名称：rm。</p>
</li>
<li><p>英文原意：remove files or directories。</p>
</li>
<li><p>所在路径：/bin/rm。</p>
</li>
<li><p>执行权限：所有用户。</p>
</li>
<li><p>功能描述：删除文件或目录。</p>
</li>
</ul>
<p>命令格式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# rm [选项] 文件或目录</span><br><span class="line">选项：   </span><br><span class="line">-f：强制删除（force）   </span><br><span class="line">-i：交互删除，在删除之前会询问用户</span><br><span class="line">-r：递归删除，可以删除目录（recursive）</span><br></pre></td></tr></table></figure>

<h2 id="2．cp命令"><a href="#2．cp命令" class="headerlink" title="2．cp命令"></a>2．cp命令</h2><p>cp是用于复制的命令，其基本信息如下：</p>
<ul>
<li>命令名称：cp。</li>
<li>英文原意：copy files and directories。</li>
<li>所在路径：/bin/cp。</li>
<li>执行权限：所有用户。</li>
<li>功能描述：复制文件和目录 。</li>
</ul>
<p>命令格式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# cp [选项] 源文件目标文件</span><br><span class="line">选项：   -a：相当于-dpr选项的集合，这几个选项我们一一介绍   </span><br><span class="line">-d：如果源文件为软链接（对硬链接无效），则复制出的目标文件也为软链接   </span><br><span class="line">-i：询问，如果目标文件已经存在，则会询问是否覆盖   </span><br><span class="line">-p：复制后目标文件保留源文件的属性（包括所有者、所属组、权限和时间）   </span><br><span class="line">-r：递归复制，用于复制目录</span><br></pre></td></tr></table></figure>

<h3 id="3．mv命令"><a href="#3．mv命令" class="headerlink" title="3．mv命令"></a>3．mv命令</h3><p>mv是用来剪切的命令，其基本信息如下。</p>
<ul>
<li>命令名称：mv。</li>
<li>英文原意：move (rename) files。</li>
<li>所在路径：/bin/mv。</li>
<li>执行权限：所有用户。</li>
<li>功能描述：移动文件或改名。</li>
</ul>
<p>命令格式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# mv [选项] 源文件目标文件</span><br><span class="line">选项：  </span><br><span class="line">-f：强制覆盖，如果目标文件已经存在，则不询问，直接强制覆盖   </span><br><span class="line">-i：交互移动，如果目标文件已经存在，则询问用户是否覆盖（默认选项）   </span><br><span class="line">-v：显示详细信息</span><br></pre></td></tr></table></figure>

<h2 id="五、基本权限管理"><a href="#五、基本权限管理" class="headerlink" title="五、基本权限管理"></a>五、基本权限管理</h2><h3 id="1．权限的介绍"><a href="#1．权限的介绍" class="headerlink" title="1．权限的介绍"></a>1．权限的介绍</h3><p>权限位的含义</p>
<p>前面讲解ls命令时，我们已经知道长格式显示的第一列就是文件的权限，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# ls -l install.log</span><br><span class="line">-rw-r--r--. 1 root root 24772 1月  14 18:17 install.log</span><br></pre></td></tr></table></figure>

<p>第一列的权限位如果不计算最后的“.”（这个点的含义我们在后面解释），则共有10位，这10位权限位的含义如图所示</p>
<p><img src="........%5Cpic%5Cqx.png" alt="qx"></p>
<ul>
<li><p>第1位代表文件类型。</p>
<p>Linux不像Windows使用扩展名表示文件类型，而是使用权限位的第1位表示文件类型。虽然Linux文件的种类不像Windows中那么多，但是分类也不少，详细情况可以使用“info ls”命令查看。在这里只讲一些常见的文件类型。   </p>
<ul>
<li>“-”：普通文件。      </li>
<li>“b”：块设备文件。这是一种特殊设备文件，存储设备都是这种文件，如分区文件/dev/sda1就是这种文件。</li>
<li>“c”：字符设备文件。这也是特殊设备文件，输入设备一般都是这种文件，如鼠标、键盘等。</li>
<li>“d”：目录文件。Linux中一切皆文件，所以目录也是文件的一种。</li>
<li>“l”：软链接文件。- “p”：管道符文件。这是一种非常少见的特殊设备文件。</li>
<li>“s”：套接字文件。这也是一种特殊设备文件，一些服务支持Socket访问，就会产生这样的文件。</li>
</ul>
</li>
<li><p>第2～4位代表文件所有者的权限。</p>
<ul>
<li>r：代表read，是读取权限。</li>
<li>w：代表write，是写权限。</li>
<li>x：代表execute，是执行权限。</li>
</ul>
</li>
</ul>
<p>如果有字母，则代表拥有对应的权限；如果是“-”，则代表没有对应的权限。</p>
<ul>
<li><p>第5～7位代表文件所属组的权限，同样拥有“rwx”权限  。</p>
</li>
<li><p>第8～10位代表其他人的权限，同样拥有“rwx”权限。</p>
</li>
</ul>
<h3 id="2．基本权限命令"><a href="#2．基本权限命令" class="headerlink" title="2．基本权限命令"></a>2．基本权限命令</h3><p>首先来看修改权限的命令chmod，其基本信息如下。</p>
<ul>
<li><p>命令名称：chmod。</p>
</li>
<li><p>英文原意：change file mode bits。</p>
</li>
<li><p>所在路径：/bin/chmod。</p>
</li>
<li><p>执行权限：所有用户。</p>
</li>
<li><p>功能描述：修改文件的权限模式。</p>
</li>
</ul>
<h4 id="2-1．命令格式"><a href="#2-1．命令格式" class="headerlink" title="2.1．命令格式"></a>2.1．命令格式</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# chmod [选项] 权限模式文件名</span><br><span class="line">选项：   </span><br><span class="line">-R：递归设置权限，也就是给子目录中的所有文件设定权限</span><br></pre></td></tr></table></figure>

<h4 id="2-2．权限模式"><a href="#2-2．权限模式" class="headerlink" title="2.2．权限模式"></a>2.2．权限模式</h4><p>chmod命令的权限模式的格式是“[ugoa][[+-=][perms]]”，也就是“[用户身份][[赋予方式][权限]]”的格式，我们来解释一下 。</p>
<ul>
<li><p>用户身份  。</p>
<ul>
<li><p>u：代表所有者（user）。</p>
</li>
<li><p>g：代表所属组（group）  。</p>
</li>
<li><p>o：代表其他人（other）。</p>
</li>
<li><p>a：代表全部身份（all）。</p>
</li>
</ul>
</li>
<li><p>赋予方式。</p>
<ul>
<li>+：加入权限。</li>
<li>-：减去权限。</li>
<li>=：设置权限。</li>
</ul>
</li>
<li><p>权限。</p>
<ul>
<li><p>r：读取权限（read）。</p>
</li>
<li><p>w：写权限（write）。</p>
</li>
<li><p>x：执行权限（execute）。</p>
</li>
</ul>
<h4 id="2-3．数字权限"><a href="#2-3．数字权限" class="headerlink" title="2.3．数字权限"></a>2.3．数字权限</h4></li>
</ul>
<p>数字权限的赋予方式是最简单的，但是不如之前的字母权限好记、直观。我们来看看这些数字权限的含义。</p>
<ul>
<li><p>4：代表“r”权限 。</p>
</li>
<li><p>2：代表“w”权限 。</p>
</li>
<li><p>1：代表“x”权限 。</p>
<h4 id="2-4．常用权限"><a href="#2-4．常用权限" class="headerlink" title="2.4．常用权限"></a>2.4．常用权限</h4></li>
</ul>
<p>数字权限的赋予方式更加简单，但是需要用户对这几个数字更加熟悉。其实常用权限也并不多，只有如下几个。</p>
<ul>
<li>644：这是文件的基本权限，代表所有者拥有读、写权限，而所属组和其他人拥有只读权限。</li>
<li>755：这是文件的执行权限和目录的基本权限，代表所有者拥有读、写和执行权限，而所属组和其他人拥有读和执行权限。</li>
<li>777：这是最大权限。在实际的生产服务器中，要尽力避免给文件或目录赋予这样的权限，这会造成一定的安全隐患。</li>
</ul>
<h3 id="3．基本权限的作用"><a href="#3．基本权限的作用" class="headerlink" title="3．基本权限的作用"></a>3．基本权限的作用</h3><h4 id="3-1．权限含义的解释首先，-读、写、执行权限对文件和目录的作用是不同的。"><a href="#3-1．权限含义的解释首先，-读、写、执行权限对文件和目录的作用是不同的。" class="headerlink" title="3.1．权限含义的解释首先，  读、写、执行权限对文件和目录的作用是不同的。"></a>3.1．权限含义的解释首先，  读、写、执行权限对文件和目录的作用是不同的。</h4><ul>
<li><p>权限对文件的作用。</p>
<ul>
<li>读（r）：对文件有读（r）权限，代表可以读取文件中的数据。如果把权限对应到命令上，那么一旦对文件有读（r）权限，就可以对文件执行cat、more、less、head、tail等文件查看命令。</li>
<li>写（w）：对文件有写（w）权限，代表可以修改文件中的数据。如果把权限对应到命令上，那么一旦对文件有写（w）权限，就可以对文件执行vim、echo等修改文件数据的命令。注意：对文件有写权限，是不能删除文件本身的，只能修改文件中的数据。如果要想删除文件，则需要对文件的上级目录拥有写权限。</li>
<li>执行（x）：对文件有执行（x）权限，代表文件拥有了执行权限，可以运行。在Linux中，只要文件有执行（x）权限，这个文件就是执行文件了。只是这个文件到底能不能正确执行，不仅需要执行（x）权限，还要看文件中的代码是不是正确的语言代码。对文件来说，执行（x）权限是最高权限。</li>
</ul>
</li>
<li><p>权限对目录的作用。</p>
<ul>
<li>读（r）：对目录有读（r）权限，代表可以查看目录下的内容，也就是可以查看目录下有哪些子文件和子目录。如果把权限对应到命令上，那么一旦对目录拥有了读（r）权限，就可以在目录下执行ls命令，查看目录下的内容了。</li>
<li>写（w）：对目录有写（r）权限，代表可以修改目录下的数据，也就是可以在目录中新建、删除、复制、剪切子文件或子目录。如果把权限对应到命令上，那么一旦对目录拥有了写（w）权限，就可以在目录下执行touch、rm、cp、mv命令。对目录来说，写（w）权限是最高权限。</li>
<li>执行（x）：目录是不能运行的，那么对目录拥有执行（x）权限，代表可以进入目录。如果把权限对应到命令上，那么一旦对目录拥有了执行（x）权限，就可以对目录执行cd命令，进入目录。</li>
</ul>
<h4 id="3-2．目录的可用权限目录的可用权限其实只有以下几个。"><a href="#3-2．目录的可用权限目录的可用权限其实只有以下几个。" class="headerlink" title="3.2．目录的可用权限目录的可用权限其实只有以下几个。"></a>3.2．目录的可用权限目录的可用权限其实只有以下几个。</h4></li>
<li><p>0：任何  权限都不赋予。</p>
</li>
<li><p>5：基本的目录浏览和进入权限。</p>
</li>
<li><p>7：完全权限。</p>
</li>
</ul>
<h3 id="4．所有者和所属组命令"><a href="#4．所有者和所属组命令" class="headerlink" title="4．所有者和所属组命令"></a>4．所有者和所属组命令</h3><h4 id="4-1．chown命令"><a href="#4-1．chown命令" class="headerlink" title="4.1．chown命令"></a>4.1．chown命令</h4><p>chown是修改文件和目录的所有者和所属组的命令，  其基本信息如下。</p>
<ul>
<li>命令名称：chown。</li>
<li>英文原意：change file owner and group。</li>
<li>所在路径：/bin/chown。执行权限：所有用户。</li>
<li>功能描述：修改文件和目录 的所有者和所属组。</li>
</ul>
<p>命令格式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# chown [选项] 所有者:所属组文件或目录</span><br><span class="line">选项：  </span><br><span class="line">-R：递归设置权限，也就是给子目录中的所有文件设置权限</span><br></pre></td></tr></table></figure>

<p>普通用户不能修改文件的所有者，哪怕自己是这个文件的所有者也不行。普通用户可以修改所有者是自己的文件的权限。</p>
<h4 id="4-2．chgrp命令"><a href="#4-2．chgrp命令" class="headerlink" title="4.2．chgrp命令"></a>4.2．chgrp命令</h4><p>chgrp是修改文件和目录的所属组的命令，其基本信息如下。</p>
<ul>
<li>命令名称：chgrp。</li>
<li>英文原意：change group ownership。</li>
<li>所在路径：/bin/chgrp。</li>
<li>执行权限：所有用户。</li>
<li>功能描述：修改文件和目录的所属</li>
</ul>
<h3 id="5．umask默认权限"><a href="#5．umask默认权限" class="headerlink" title="5．umask默认权限"></a>5．umask默认权限</h3><h4 id="5-1-查看系统的umask权限"><a href="#5-1-查看系统的umask权限" class="headerlink" title="5.1 查看系统的umask权限"></a>5.1 查看系统的umask权限</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# umask </span><br><span class="line">0022 </span><br><span class="line">#用八进制数值显示umask权限</span><br><span class="line">[root@localhost ~]# umask -S </span><br><span class="line">u&#x3D;rwx,g&#x3D;rx,o&#x3D;rx </span><br><span class="line">#用字母表示文件和目录的初始权限</span><br></pre></td></tr></table></figure>

<h4 id="5-2-umask权限的计算方法"><a href="#5-2-umask权限的计算方法" class="headerlink" title="5.2 umask权限的计算方法"></a>5.2 umask权限的计算方法</h4><p>我们需要先了解一下新建文件和目录的默认最大权限。</p>
<ul>
<li>对文件来讲，新建文件的默认最大权限是666，没有执行（x）权限。这是因为执行权限对文件来讲比较危险，不能在新建文件的时候默认赋予，而必须通过用户手工赋予。</li>
<li>对目录来讲，新建目录的默认最大权限是777。这是因为对目录而言，执行（x）权限仅仅代表进入目录，所以即使建立新文件时直接默认赋予，也没有什么危险。</li>
</ul>
<p>按照官方的标准算法，umask默认权限需要使用二进制进行逻辑与和逻辑非联合运算才可以得到正确的新建文件和目录的默认权限。这种方法既不好计算，也不好理解。我们在这里还是按照权限字母来讲解umask权限的计算方法。我们就按照默认的umask值是022来分别计算一下新建文件和目录的默认权限吧。</p>
<ul>
<li>文件的默认权限最大只能是666，而umask的值是022“-rw-rw-rw-”减去“—–w–w-”等于“-rw-r–r—”</li>
<li>目录的默认权限最大可以是777，而umask的值是022“drwxrwxrwx”减去“d—-w–w-”等于“drwx-r-xr-x”</li>
</ul>
<h5 id="注意：umask默认权限的计算绝不是数字直接相减。"><a href="#注意：umask默认权限的计算绝不是数字直接相减。" class="headerlink" title="注意：umask默认权限的计算绝不是数字直接相减。"></a>注意：umask默认权限的计算绝不是数字直接相减。</h5><p>例如umask是033呢？</p>
<ul>
<li>文件的默认权限最大只能是666，而umask的值是033“-rw-rw-rw-”减去“—–wx-wx”等于“-rw-r– r—”</li>
</ul>
<h2 id="六、帮助命令"><a href="#六、帮助命令" class="headerlink" title="六、帮助命令"></a>六、帮助命令</h2><h3 id="1．man命令"><a href="#1．man命令" class="headerlink" title="1．man命令"></a>1．man命令</h3><p>man是最常见的帮助命令，也是Linux最主要的帮助命令，其基本信息如下。</p>
<ul>
<li>命令名称：man。</li>
<li>英文原意：format and display the on-line manual pages。</li>
<li>所在路径：/usr/bin/man。</li>
<li>执行权限：所有用户。</li>
<li>功能描述：显示联机帮助手册。</li>
</ul>
<p>命令格式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# man [选项] 命令</span><br><span class="line">选项：   </span><br><span class="line">-f：查看命令拥有哪个级别的帮助   </span><br><span class="line">-k：查看和命令相关的所有帮助</span><br></pre></td></tr></table></figure>

<p>man命令的快捷键</p>
<table>
<thead>
<tr>
<th>快捷键</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>上箭头</td>
<td>向上移动一行</td>
</tr>
<tr>
<td>下箭头</td>
<td>向下移动一行</td>
</tr>
<tr>
<td>PgUp</td>
<td>向上翻一页</td>
</tr>
<tr>
<td>PgDn</td>
<td>向下翻一页</td>
</tr>
<tr>
<td>g</td>
<td>移动到第一页</td>
</tr>
<tr>
<td>G</td>
<td>移动到最后一页</td>
</tr>
<tr>
<td>q</td>
<td>退出</td>
</tr>
<tr>
<td>/字符串</td>
<td>从当前页向下搜索字符串</td>
</tr>
<tr>
<td>?字符串</td>
<td>从当前页向上搜索字符串</td>
</tr>
<tr>
<td>n</td>
<td>当搜索字符串时，可以使用n键找到下一个字符串</td>
</tr>
<tr>
<td>N</td>
<td>当搜索字符串时，使用N键反向查询字符串。也就是说，如果使用“/字符串”方式搜索，则N键表示向上搜索字符串；如果使用“?字符串”方式搜索，则N键表示 向下搜索字符串</td>
</tr>
</tbody></table>
<p>man命令的帮助级别</p>
<table>
<thead>
<tr>
<th>级别</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>普通用户可以执行的系统命令和可执行文件的帮助</td>
</tr>
<tr>
<td>2</td>
<td>内核可以调用的函数和工具的帮助</td>
</tr>
<tr>
<td>3</td>
<td>C语言函数的帮助</td>
</tr>
<tr>
<td>4</td>
<td>设备和特殊文件的帮助</td>
</tr>
<tr>
<td>5</td>
<td>配置文件的帮助</td>
</tr>
<tr>
<td>6</td>
<td>游戏的帮助（个人版的Linux中是有游戏的）</td>
</tr>
<tr>
<td>7</td>
<td>杂项的帮助</td>
</tr>
<tr>
<td>8</td>
<td>超级用户可以执行的系统命令的帮助</td>
</tr>
<tr>
<td>9</td>
<td>内核的帮助</td>
</tr>
</tbody></table>
<p>man    -f    命令或     whatis    命令</p>
<p>#查看命令拥有哪个级别的帮助</p>
<p>man    -k    命令或    apropos命令</p>
<p>#查看和命令相关的所有帮助</p>
<h3 id="2．info命令"><a href="#2．info命令" class="headerlink" title="2．info命令"></a>2．info命令</h3><p>info命令的帮助信息是一套完整的资料，每个单独命令的帮助信息只是这套完整资料中的某一个小章节。</p>
<table>
<thead>
<tr>
<th>快捷键</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>上箭头</td>
<td>向上移动一行</td>
</tr>
<tr>
<td>下箭头</td>
<td>向下移动一行</td>
</tr>
<tr>
<td>PgUp</td>
<td>向上翻一页</td>
</tr>
<tr>
<td>PgDn</td>
<td>向下翻一页</td>
</tr>
<tr>
<td>Tab</td>
<td>在有“*”符 号的节点间进行切换</td>
</tr>
<tr>
<td>回车</td>
<td>进入有“*”符号的子页面，查看详细帮助信息</td>
</tr>
<tr>
<td>u</td>
<td>进入上一层信息（回车是进入下一层信息）</td>
</tr>
<tr>
<td>n</td>
<td>进入下一小节信息</td>
</tr>
<tr>
<td>p</td>
<td>进入上一小节信息</td>
</tr>
<tr>
<td>?</td>
<td>查看帮助信息</td>
</tr>
<tr>
<td>q</td>
<td>退出info信息</td>
</tr>
</tbody></table>
<h3 id="3．help命令"><a href="#3．help命令" class="headerlink" title="3．help命令"></a>3．help命令</h3><p>help只能获取Shell内置命令的帮助help命令的基本信息如下。</p>
<ul>
<li><p>命令名称：help。</p>
</li>
<li><p>英文原意：help。</p>
</li>
<li><p>所在路径：Shell内置命令。</p>
</li>
<li><p>执行权限：所有用户。</p>
</li>
<li><p>功能描述：显示Shell内置命令的帮助。可以使用type命令来区分内置命令与外部命令。shell是Linux的命令解释器。</p>
</li>
</ul>
<h3 id="4．–help选项"><a href="#4．–help选项" class="headerlink" title="4．–help选项"></a>4．–help选项</h3><p>绝大多数命令都可以使用“–help”选项来查看帮助，这也是一种获取帮助的方法。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# ls --help</span><br></pre></td></tr></table></figure>

<p> 这种方法非常简单，输出的帮助信息基本上是man命令的信息简要版。对于这4种常见的  获取帮助的方法，大家可以按照自己的习惯任意使</p>
<h2 id="七、搜索命令"><a href="#七、搜索命令" class="headerlink" title="七、搜索命令"></a>七、搜索命令</h2><h3 id="1．whereis命令"><a href="#1．whereis命令" class="headerlink" title="1．whereis命令"></a>1．whereis命令</h3><p>whereis是搜索系统命令的命令（像绕口令一样），也就是说，whereis命令不能搜索普通文件，而只能搜索系统命令。whereis命令的基本信息如下。</p>
<ul>
<li>命令名称：whereis。</li>
<li>英文原意：locate the binary, source, and manual page files for a command。</li>
<li>所在路径：/usr/bin/whereis。执行权限：所有用户。</li>
<li>功能描述：查找二进制命令、源文件和帮助文档的命令。</li>
</ul>
<h3 id="2．which命令"><a href="#2．which命令" class="headerlink" title="2．which命令"></a>2．which命令</h3><p>which也是搜索  系统命令的命令。和whereis命令的区别在于：</p>
<ul>
<li><p>whereis命令可以  在查找 到二进制命令的同时，查找到帮助文档的位置；</p>
</li>
<li><p>而which命令在查找到二进制命令的同时，如果这个命令有别名，则还可以找到别名命令。</p>
</li>
</ul>
<p>which命令的基本信息如下</p>
<ul>
<li>命令名称：which。</li>
<li>英文原意：shows the full path of (shell) commands。</li>
<li>所在路径：/usr/bin/which。</li>
<li>执行权限：所有用户。</li>
<li>功能描述：列出命令的所在路径。</li>
</ul>
<h3 id="3．locate命令"><a href="#3．locate命令" class="headerlink" title="3．locate命令"></a>3．locate命令</h3><h4 id="3-1基本用法"><a href="#3-1基本用法" class="headerlink" title="3.1基本用法"></a>3.1基本用法</h4><p>locate命令才是可以按照文件名搜索普通文件的命令。</p>
<ul>
<li>优点：按照数据库搜索，搜索速度快，消耗资源小。数据库位置/var/lib/mlocate/mlocate.db，可以使用updatedb命令强制更新数据库。</li>
<li>缺点：只能按照文件名来搜索文件，而不能执行更复杂的搜索，比如按照权限、大小、修改时间等搜索文件。</li>
</ul>
<p>locate命令的基本信息如下。</p>
<ul>
<li><p>命令名称：locate。</p>
</li>
<li><p>英文原意：find files by name。</p>
</li>
<li><p>所在路径：/usr/bin/locate。</p>
</li>
<li><p>执行权限：所有用户。</p>
</li>
<li><p>功能描述：按照文件名搜索文件。</p>
<h4 id="3-2配置文件"><a href="#3-2配置文件" class="headerlink" title="3.2配置文件"></a>3.2配置文件</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# vi &#x2F;etc&#x2F;updatedb.conf </span><br><span class="line">PRUNE_BIND_MOUNTS &#x3D; &quot;yes&quot; </span><br><span class="line">#开启搜索限制，也就是让这个配置文件生效</span><br><span class="line">PRUNEFS &#x3D; &quot;......&quot; </span><br><span class="line">#在locate执行搜索时，禁止搜索这些文件系统类型</span><br><span class="line">PRUNENAMES &#x3D; &quot;......&quot; </span><br><span class="line">#在locate执行搜索时，禁止搜索带有这些扩展名的文件</span><br><span class="line">PRUNEPATHS &#x3D; &quot;......&quot; </span><br><span class="line">#在locate执行搜索时，禁止搜索这些系统目录</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="4．find命令"><a href="#4．find命令" class="headerlink" title="4．find命令"></a>4．find命令</h3><p>find命令的基本信息如下。</p>
<ul>
<li><p>命令名称：find。</p>
</li>
<li><p>英文原意：search for files in a directory hierarchy。</p>
</li>
<li><p>所在路径：/bin/find。</p>
</li>
<li><p>执行权限：所有用户。</p>
</li>
<li><p>功能描述：在目录中搜索文件。</p>
<h4 id="4-1按照文件名搜索"><a href="#4-1按照文件名搜索" class="headerlink" title="4.1按照文件名搜索"></a>4.1按照文件名搜索</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# find 搜索路径[选项] 搜索内容</span><br><span class="line">选项：   </span><br><span class="line">-name：按照文件名搜索   </span><br><span class="line">-iname：按照文件名搜索，不区分文件名大小写   </span><br><span class="line">-inum：按照inode号搜索</span><br></pre></td></tr></table></figure>

<h4 id="4-2．按照文件大小搜索"><a href="#4-2．按照文件大小搜索" class="headerlink" title="4.2．按照文件大小搜索"></a>4.2．按照文件大小搜索</h4></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# find 搜索路径[选项] 搜索内容</span><br><span class="line">选项：   </span><br><span class="line">-size [+|-]大小：按照指定大小搜索文件</span><br></pre></td></tr></table></figure>

<p>这里的“+”的意思是搜索比指定大小还要大的文件，“-”的意思是搜索比指定大小还要小的文件。</p>
<p>find命令的单位：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# man find        </span><br><span class="line">-size n[cwbkMG]              </span><br><span class="line">File uses n units of space.  The following suffixes can be used:               </span><br><span class="line">&#39;b&#39;    for 512-byte blocks (this is the default if no suffix is used) #这是默认单位，如果单位为b或不写单位，则按照512 Byte搜索              </span><br><span class="line">&#39;c&#39;    for bytes     #搜索单位是c，按照字节搜索              </span><br><span class="line">&#39;w&#39;    for two-byte words #搜索单位是w，按照双字节（中文）搜索              </span><br><span class="line">&#39;k&#39;    for Kilobytes (units of 1024 bytes)     #按照KB单位搜索，必须是小写的k               </span><br><span class="line">&#39;M&#39;    for Megabytes (units of 1048576 bytes) #按照MB单位搜索，必须是大写的M               </span><br><span class="line">&#39;G&#39;    for Gigabytes (units of 1073741824 bytes)     #按照GB单位搜索，必须是大写的G</span><br></pre></td></tr></table></figure>

<h4 id="4-3按照修改时间搜索"><a href="#4-3按照修改时间搜索" class="headerlink" title="4.3按照修改时间搜索"></a>4.3按照修改时间搜索</h4><p>Linux中的文件有访问时间（atime）、数据修改时间（mtime）、状态修改时间（ctime）这三个时间，我们也可以按照时间来搜索文件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# find 搜索路径[选项] 搜索内容</span><br><span class="line">选项：   </span><br><span class="line">-atime [+|-]时间：按照文件访问时间搜索   </span><br><span class="line">-mtime [+|-]时间：按照文件数据修改时间搜索   </span><br><span class="line">-ctime [+|-]时间：按照文件状态修改时间搜索</span><br></pre></td></tr></table></figure>

<p>这三个时间的区别我们在stat命令中已经解释过了，这里用mtime数据修改时间来举例，重点说说“[+-]”时间的含义。</p>
<ul>
<li>-5：代表5天内修改的文件。</li>
<li>5：代表前5～6天那一天修改的文件。</li>
<li>+5：代表6天前修改的文件。</li>
</ul>
<p>我们画一个时间轴，来解释一下</p>
<p><img src="........%5Cpic%5Css.png" alt="ss"></p>
]]></content>
      <tags>
        <tag>linux运维基础</tag>
      </tags>
  </entry>
</search>
